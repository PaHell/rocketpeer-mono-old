// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR: &'static str =
    include_str!("C:\\Users\\artin\\repos\\rocketpeer-mono\\rust\\prisma\\schema.prisma");
static DATABASE_STR: &'static str = "mysql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod users {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "users";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserName(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UserNameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            UserName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod password {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "password";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPassword(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Password(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Password(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Password(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Password,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Password(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Password(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod display_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "display_name";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDisplayName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DisplayName(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DisplayName(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::DisplayName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            DisplayName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DisplayName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DisplayName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod first_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "first_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFirstName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FirstName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FirstName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::FirstName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            FirstName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FirstName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FirstName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod last_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "last_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLastName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::LastName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::LastName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            LastName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod image {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "image";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetImage(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Image(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Image(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Image(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Image,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Image(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Image(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod status {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "status";
        pub struct Set(pub self::UsersStatus);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStatus(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Status(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::UsersStatus) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Status(direction)
        }
        pub fn equals(value: self::UsersStatus) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::users_statusFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::users_statusFilter,
            Status,
            {
                fn in_vec(_: Vec<super::super::UsersStatus>) -> InVec;
                fn not_in_vec(_: Vec<super::super::UsersStatus>) -> NotInVec;
                fn not(_: super::super::UsersStatus) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Status(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Status(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod privacy_level {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "privacy_level";
        pub struct Set(pub self::UsersPrivacyLevel);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPrivacyLevel(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PrivacyLevel(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::UsersPrivacyLevel) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PrivacyLevel(direction)
        }
        pub fn equals(value: self::UsersPrivacyLevel) -> WhereParam {
            WhereParam::PrivacyLevel(_prisma::read_filters::users_privacy_levelFilter::Equals(
                value,
            ))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::users_privacy_levelFilter,
            PrivacyLevel,
            {
                fn in_vec(_: Vec<super::super::UsersPrivacyLevel>) -> InVec;
                fn not_in_vec(_: Vec<super::super::UsersPrivacyLevel>) -> NotInVec;
                fn not(_: super::super::UsersPrivacyLevel) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PrivacyLevel(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PrivacyLevel(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "role";
        pub struct Set(pub self::UsersRole);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRole(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Role(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::UsersRole) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub fn equals(value: self::UsersRole) -> WhereParam {
            WhereParam::Role(_prisma::read_filters::users_roleFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::users_roleFilter,
            Role,
            {
                fn in_vec(_: Vec<super::super::UsersRole>) -> InVec;
                fn not_in_vec(_: Vec<super::super::UsersRole>) -> NotInVec;
                fn not(_: super::super::UsersRole) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Role(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Role(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod access_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "access_token";
        pub struct Fetch(pub access_token::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<access_token::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::AccessToken(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(access_token::UniqueArgs::new())
        }
        pub struct Connect(access_token::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectAccessToken(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: access_token::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectAccessToken
        }
        pub fn is_null() -> WhereParam {
            WhereParam::AccessTokenIsNull
        }
        pub fn is(value: Vec<access_token::WhereParam>) -> WhereParam {
            WhereParam::AccessTokenIs(value)
        }
        pub fn is_not(value: Vec<access_token::WhereParam>) -> WhereParam {
            WhereParam::AccessTokenIsNot(value)
        }
        pub enum Include {
            Select(Vec<access_token::SelectParam>),
            Include(Vec<access_token::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AccessToken(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < access_token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <access_token::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("access_token", None, [], selections)
            }
            pub fn select(nested_selections: Vec<access_token::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<access_token::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<access_token::SelectParam>),
            Include(Vec<access_token::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AccessToken(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <access_token::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("access_token", None, [], selections)
            }
            pub fn select(nested_selections: Vec<access_token::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<access_token::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod message_receiver {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "message_receiver";
        pub struct Fetch(pub message::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: message::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: message::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::MessageReceiver(v)
            }
        }
        pub fn fetch(params: Vec<message::WhereParam>) -> Fetch {
            Fetch(message::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<message::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMessageReceiver(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<message::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMessageReceiver(params)
        }
        pub fn set(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::SetMessageReceiver(params)
        }
        pub fn some(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageReceiverSome(value)
        }
        pub fn every(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageReceiverEvery(value)
        }
        pub fn none(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageReceiverNone(value)
        }
        pub enum Include {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageReceiver(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageReceiver(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod message_sender {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "message_sender";
        pub struct Fetch(pub message::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<message::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: message::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: message::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::MessageSender(v)
            }
        }
        pub fn fetch(params: Vec<message::WhereParam>) -> Fetch {
            Fetch(message::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<message::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMessageSender(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<message::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMessageSender(params)
        }
        pub fn set(params: Vec<message::UniqueWhereParam>) -> SetParam {
            SetParam::SetMessageSender(params)
        }
        pub fn some(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageSenderSome(value)
        }
        pub fn every(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageSenderEvery(value)
        }
        pub fn none(value: Vec<message::WhereParam>) -> WhereParam {
            WhereParam::MessageSenderNone(value)
        }
        pub enum Include {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageSender(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(message::ManyArgs, Vec<message::SelectParam>),
            Include(message::ManyArgs, Vec<message::IncludeParam>),
            Fetch(message::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageSender(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <message::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: message::ManyArgs,
                nested_selections: Vec<message::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: message::ManyArgs,
                nested_selections: Vec<message::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod text_channel_messages {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text_channel_messages";
        pub struct Fetch(pub text_channel_messages::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<text_channel_messages::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: text_channel_messages::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: text_channel_messages::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::TextChannelMessages(v)
            }
        }
        pub fn fetch(params: Vec<text_channel_messages::WhereParam>) -> Fetch {
            Fetch(text_channel_messages::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<text_channel_messages::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTextChannelMessages(v)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<text_channel_messages::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<text_channel_messages::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTextChannelMessages(params)
        }
        pub fn set(params: Vec<text_channel_messages::UniqueWhereParam>) -> SetParam {
            SetParam::SetTextChannelMessages(params)
        }
        pub fn some(value: Vec<text_channel_messages::WhereParam>) -> WhereParam {
            WhereParam::TextChannelMessagesSome(value)
        }
        pub fn every(value: Vec<text_channel_messages::WhereParam>) -> WhereParam {
            WhereParam::TextChannelMessagesEvery(value)
        }
        pub fn none(value: Vec<text_channel_messages::WhereParam>) -> WhereParam {
            WhereParam::TextChannelMessagesNone(value)
        }
        pub enum Include {
            Select(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::SelectParam>,
            ),
            Include(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::IncludeParam>,
            ),
            Fetch(text_channel_messages::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TextChannelMessages(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::SelectParam>,
            ),
            Include(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::IncludeParam>,
            ),
            Fetch(text_channel_messages::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TextChannelMessages(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod friends_user_1 {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "friends_user_1";
        pub struct Fetch(pub user_friends::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user_friends::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user_friends::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: user_friends::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FriendsUser1(v)
            }
        }
        pub fn fetch(params: Vec<user_friends::WhereParam>) -> Fetch {
            Fetch(user_friends::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<user_friends::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFriendsUser1(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<user_friends::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<user_friends::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFriendsUser1(params)
        }
        pub fn set(params: Vec<user_friends::UniqueWhereParam>) -> SetParam {
            SetParam::SetFriendsUser1(params)
        }
        pub fn some(value: Vec<user_friends::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser1Some(value)
        }
        pub fn every(value: Vec<user_friends::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser1Every(value)
        }
        pub fn none(value: Vec<user_friends::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser1None(value)
        }
        pub enum Include {
            Select(user_friends::ManyArgs, Vec<user_friends::SelectParam>),
            Include(user_friends::ManyArgs, Vec<user_friends::IncludeParam>),
            Fetch(user_friends::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FriendsUser1(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(user_friends::ManyArgs, Vec<user_friends::SelectParam>),
            Include(user_friends::ManyArgs, Vec<user_friends::IncludeParam>),
            Fetch(user_friends::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FriendsUser1(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod friends_user_2 {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "friends_user_2";
        pub struct Fetch(pub user_friends::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user_friends::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user_friends::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: user_friends::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FriendsUser2(v)
            }
        }
        pub fn fetch(params: Vec<user_friends::WhereParam>) -> Fetch {
            Fetch(user_friends::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<user_friends::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFriendsUser2(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<user_friends::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<user_friends::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFriendsUser2(params)
        }
        pub fn set(params: Vec<user_friends::UniqueWhereParam>) -> SetParam {
            SetParam::SetFriendsUser2(params)
        }
        pub fn some(value: Vec<user_friends::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser2Some(value)
        }
        pub fn every(value: Vec<user_friends::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser2Every(value)
        }
        pub fn none(value: Vec<user_friends::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser2None(value)
        }
        pub enum Include {
            Select(user_friends::ManyArgs, Vec<user_friends::SelectParam>),
            Include(user_friends::ManyArgs, Vec<user_friends::IncludeParam>),
            Fetch(user_friends::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FriendsUser2(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(user_friends::ManyArgs, Vec<user_friends::SelectParam>),
            Include(user_friends::ManyArgs, Vec<user_friends::IncludeParam>),
            Fetch(user_friends::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FriendsUser2(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_friends::ManyArgs,
                nested_selections: Vec<user_friends::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod users_servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_servers";
        pub struct Fetch(pub users_servers::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users_servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: users_servers::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: users_servers::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersServers(v)
            }
        }
        pub fn fetch(params: Vec<users_servers::WhereParam>) -> Fetch {
            Fetch(users_servers::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<users_servers::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<users_servers::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<users_servers::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUsersServers(params)
        }
        pub fn set(params: Vec<users_servers::UniqueWhereParam>) -> SetParam {
            SetParam::SetUsersServers(params)
        }
        pub fn some(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersSome(value)
        }
        pub fn every(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersEvery(value)
        }
        pub fn none(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersNone(value)
        }
        pub enum Include {
            Select(users_servers::ManyArgs, Vec<users_servers::SelectParam>),
            Include(users_servers::ManyArgs, Vec<users_servers::IncludeParam>),
            Fetch(users_servers::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersServers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(users_servers::ManyArgs, Vec<users_servers::SelectParam>),
            Include(users_servers::ManyArgs, Vec<users_servers::IncludeParam>),
            Fetch(users_servers::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersServers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        user_name: String,
        password: String,
        first_name: String,
        last_name: String,
        image: String,
        status: super::UsersStatus,
        email: String,
        privacy_level: super::UsersPrivacyLevel,
        role: super::UsersRole,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        super::UsersStatus,
        String,
        super::UsersPrivacyLevel,
        super::UsersRole,
        Vec<SetParam>,
    ) {
        (
            user_name,
            password,
            first_name,
            last_name,
            image,
            status,
            email,
            privacy_level,
            role,
            _params,
        )
    }
    pub fn create_unchecked(
        user_name: String,
        password: String,
        first_name: String,
        last_name: String,
        image: String,
        status: super::UsersStatus,
        email: String,
        privacy_level: super::UsersPrivacyLevel,
        role: super::UsersRole,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        String,
        String,
        super::UsersStatus,
        String,
        super::UsersPrivacyLevel,
        super::UsersRole,
        Vec<SetParam>,
    ) {
        (
            user_name,
            password,
            first_name,
            last_name,
            image,
            status,
            email,
            privacy_level,
            role,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , user_name , password , display_name , first_name , last_name , image , status , email , privacy_level , role , created_at , access_token , message_receiver , message_sender , text_channel_messages , friends_user_1 , friends_user_2 , users_servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: users :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_name" , "password" , "display_name" , "first_name" , "last_name" , "image" , "status" , "email" , "privacy_level" , "role" , "created_at" , "access_token" , "message_receiver" , "message_sender" , "text_channel_messages" , "friends_user_1" , "friends_user_2" , "users_servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; user_name) => { String } ; (@ field_type ; password) => { String } ; (@ field_type ; display_name) => { Option < String > } ; (@ field_type ; first_name) => { String } ; (@ field_type ; last_name) => { String } ; (@ field_type ; image) => { String } ; (@ field_type ; status) => { crate :: prisma :: UsersStatus } ; (@ field_type ; email) => { String } ; (@ field_type ; privacy_level) => { crate :: prisma :: UsersPrivacyLevel } ; (@ field_type ; role) => { crate :: prisma :: UsersRole } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; access_token : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < access_token :: Data > } ; (@ field_type ; access_token) => { Option < crate :: prisma :: access_token :: Data > } ; (@ field_type ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < message_receiver :: Data > } ; (@ field_type ; message_receiver) => { Vec < crate :: prisma :: message :: Data > } ; (@ field_type ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < message_sender :: Data > } ; (@ field_type ; message_sender) => { Vec < crate :: prisma :: message :: Data > } ; (@ field_type ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channel_messages :: Data > } ; (@ field_type ; text_channel_messages) => { Vec < crate :: prisma :: text_channel_messages :: Data > } ; (@ field_type ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_user_1 :: Data > } ; (@ field_type ; friends_user_1) => { Vec < crate :: prisma :: user_friends :: Data > } ; (@ field_type ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_user_2 :: Data > } ; (@ field_type ; friends_user_2) => { Vec < crate :: prisma :: user_friends :: Data > } ; (@ field_type ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_servers :: Data > } ; (@ field_type ; users_servers) => { Vec < crate :: prisma :: users_servers :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Users" , available relations are "id, user_name, password, display_name, first_name, last_name, image, status, email, privacy_level, role, created_at, access_token, message_receiver, message_sender, text_channel_messages, friends_user_1, friends_user_2, users_servers")) } ; (@ field_module ; access_token : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: access_token :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: message :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: message :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channel_messages :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_friends :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_friends :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: id :: Select) } ; (@ selection_field_to_selection_param ; user_name) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: user_name :: Select) } ; (@ selection_field_to_selection_param ; password) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: password :: Select) } ; (@ selection_field_to_selection_param ; display_name) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: display_name :: Select) } ; (@ selection_field_to_selection_param ; first_name) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: first_name :: Select) } ; (@ selection_field_to_selection_param ; last_name) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: last_name :: Select) } ; (@ selection_field_to_selection_param ; image) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: image :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: status :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: email :: Select) } ; (@ selection_field_to_selection_param ; privacy_level) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: privacy_level :: Select) } ; (@ selection_field_to_selection_param ; role) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: role :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: created_at :: Select) } ; (@ selection_field_to_selection_param ; access_token $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: access_token :: Select :: $ selection_mode (crate :: prisma :: access_token :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; access_token $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: access_token :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: message_receiver :: Select :: $ selection_mode (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: message :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: message_receiver :: Select :: Fetch (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: message_sender :: Select :: $ selection_mode (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: message :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: message_sender :: Select :: Fetch (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: text_channel_messages :: Select :: $ selection_mode (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channel_messages :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: text_channel_messages :: Select :: Fetch (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: friends_user_1 :: Select :: $ selection_mode (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_friends :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: friends_user_1 :: Select :: Fetch (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: friends_user_2 :: Select :: $ selection_mode (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_friends :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: friends_user_2 :: Select :: Fetch (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: users_servers :: Select :: $ selection_mode (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: users_servers :: Select :: Fetch (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_name) => { "user_name" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; display_name) => { "display_name" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; image) => { "image" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; privacy_level) => { "privacy_level" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; access_token) => { "access_token" } ; (@ field_serde_name ; message_receiver) => { "message_receiver" } ; (@ field_serde_name ; message_sender) => { "message_sender" } ; (@ field_serde_name ; text_channel_messages) => { "text_channel_messages" } ; (@ field_serde_name ; friends_user_1) => { "friends_user_1" } ; (@ field_serde_name ; friends_user_2) => { "friends_user_2" } ; (@ field_serde_name ; users_servers) => { "users_servers" } ; }
    pub use _select_users as select;
    pub enum SelectParam {
        Id(id::Select),
        UserName(user_name::Select),
        Password(password::Select),
        DisplayName(display_name::Select),
        FirstName(first_name::Select),
        LastName(last_name::Select),
        Image(image::Select),
        Status(status::Select),
        Email(email::Select),
        PrivacyLevel(privacy_level::Select),
        Role(role::Select),
        CreatedAt(created_at::Select),
        AccessToken(access_token::Select),
        MessageReceiver(message_receiver::Select),
        MessageSender(message_sender::Select),
        TextChannelMessages(text_channel_messages::Select),
        FriendsUser1(friends_user_1::Select),
        FriendsUser2(friends_user_2::Select),
        UsersServers(users_servers::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserName(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::Image(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::PrivacyLevel(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::AccessToken(data) => data.to_selection(),
                Self::MessageReceiver(data) => data.to_selection(),
                Self::MessageSender(data) => data.to_selection(),
                Self::TextChannelMessages(data) => data.to_selection(),
                Self::FriendsUser1(data) => data.to_selection(),
                Self::FriendsUser2(data) => data.to_selection(),
                Self::UsersServers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { access_token , message_receiver , message_sender , text_channel_messages , friends_user_1 , friends_user_2 , users_servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub user_name : String , pub password : String , pub display_name : Option < String > , pub first_name : String , pub last_name : String , pub image : String , pub status : crate :: prisma :: UsersStatus , pub email : String , pub privacy_level : crate :: prisma :: UsersPrivacyLevel , pub role : crate :: prisma :: UsersRole , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: users :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_name) , stringify ! (password) , stringify ! (display_name) , stringify ! (first_name) , stringify ! (last_name) , stringify ! (image) , stringify ! (status) , stringify ! (email) , stringify ! (privacy_level) , stringify ! (role) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: users :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: users :: user_name :: NAME , & self . user_name) ? ; state . serialize_field (crate :: prisma :: users :: password :: NAME , & self . password) ? ; state . serialize_field (crate :: prisma :: users :: display_name :: NAME , & self . display_name) ? ; state . serialize_field (crate :: prisma :: users :: first_name :: NAME , & self . first_name) ? ; state . serialize_field (crate :: prisma :: users :: last_name :: NAME , & self . last_name) ? ; state . serialize_field (crate :: prisma :: users :: image :: NAME , & self . image) ? ; state . serialize_field (crate :: prisma :: users :: status :: NAME , & self . status) ? ; state . serialize_field (crate :: prisma :: users :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: users :: privacy_level :: NAME , & self . privacy_level) ? ; state . serialize_field (crate :: prisma :: users :: role :: NAME , & self . role) ? ; state . serialize_field (crate :: prisma :: users :: created_at :: NAME , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , user_name , password , display_name , first_name , last_name , image , status , email , privacy_level , role , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users :: $ field :: NAME) , + , crate :: prisma :: users :: id :: NAME , crate :: prisma :: users :: user_name :: NAME , crate :: prisma :: users :: password :: NAME , crate :: prisma :: users :: display_name :: NAME , crate :: prisma :: users :: first_name :: NAME , crate :: prisma :: users :: last_name :: NAME , crate :: prisma :: users :: image :: NAME , crate :: prisma :: users :: status :: NAME , crate :: prisma :: users :: email :: NAME , crate :: prisma :: users :: privacy_level :: NAME , crate :: prisma :: users :: role :: NAME , crate :: prisma :: users :: created_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: users :: id :: NAME => Ok (Field :: id) , crate :: prisma :: users :: user_name :: NAME => Ok (Field :: user_name) , crate :: prisma :: users :: password :: NAME => Ok (Field :: password) , crate :: prisma :: users :: display_name :: NAME => Ok (Field :: display_name) , crate :: prisma :: users :: first_name :: NAME => Ok (Field :: first_name) , crate :: prisma :: users :: last_name :: NAME => Ok (Field :: last_name) , crate :: prisma :: users :: image :: NAME => Ok (Field :: image) , crate :: prisma :: users :: status :: NAME => Ok (Field :: status) , crate :: prisma :: users :: email :: NAME => Ok (Field :: email) , crate :: prisma :: users :: privacy_level :: NAME => Ok (Field :: privacy_level) , crate :: prisma :: users :: role :: NAME => Ok (Field :: role) , crate :: prisma :: users :: created_at :: NAME => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut user_name = None ; let mut password = None ; let mut display_name = None ; let mut first_name = None ; let mut last_name = None ; let mut image = None ; let mut status = None ; let mut email = None ; let mut privacy_level = None ; let mut role = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: user_name => { if user_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: user_name :: NAME)) ; } user_name = Some (map . next_value () ?) ; } Field :: password => { if password . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: password :: NAME)) ; } password = Some (map . next_value () ?) ; } Field :: display_name => { if display_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: display_name :: NAME)) ; } display_name = Some (map . next_value () ?) ; } Field :: first_name => { if first_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: first_name :: NAME)) ; } first_name = Some (map . next_value () ?) ; } Field :: last_name => { if last_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: last_name :: NAME)) ; } last_name = Some (map . next_value () ?) ; } Field :: image => { if image . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: image :: NAME)) ; } image = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: status :: NAME)) ; } status = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: privacy_level => { if privacy_level . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: privacy_level :: NAME)) ; } privacy_level = Some (map . next_value () ?) ; } Field :: role => { if role . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: role :: NAME)) ; } role = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: id :: NAME)) ? ; let user_name = user_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: user_name :: NAME)) ? ; let password = password . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: password :: NAME)) ? ; let display_name = display_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: display_name :: NAME)) ? ; let first_name = first_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: first_name :: NAME)) ? ; let last_name = last_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: last_name :: NAME)) ? ; let image = image . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: image :: NAME)) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: status :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: email :: NAME)) ? ; let privacy_level = privacy_level . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: privacy_level :: NAME)) ? ; let role = role . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: role :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: created_at :: NAME)) ? ; Ok (Data { id , user_name , password , display_name , first_name , last_name , image , status , email , privacy_level , role , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_name" , "password" , "display_name" , "first_name" , "last_name" , "image" , "status" , "email" , "privacy_level" , "role" , "created_at" , "access_token" , "message_receiver" , "message_sender" , "text_channel_messages" , "friends_user_1" , "friends_user_2" , "users_servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; access_token : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < access_token :: Data > } ; (@ field_type ; access_token) => { Option < crate :: prisma :: access_token :: Data > } ; (@ field_type ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < message_receiver :: Data > } ; (@ field_type ; message_receiver) => { Vec < crate :: prisma :: message :: Data > } ; (@ field_type ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < message_sender :: Data > } ; (@ field_type ; message_sender) => { Vec < crate :: prisma :: message :: Data > } ; (@ field_type ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channel_messages :: Data > } ; (@ field_type ; text_channel_messages) => { Vec < crate :: prisma :: text_channel_messages :: Data > } ; (@ field_type ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_user_1 :: Data > } ; (@ field_type ; friends_user_1) => { Vec < crate :: prisma :: user_friends :: Data > } ; (@ field_type ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < friends_user_2 :: Data > } ; (@ field_type ; friends_user_2) => { Vec < crate :: prisma :: user_friends :: Data > } ; (@ field_type ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_servers :: Data > } ; (@ field_type ; users_servers) => { Vec < crate :: prisma :: users_servers :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Users" , available relations are "access_token, message_receiver, message_sender, text_channel_messages, friends_user_1, friends_user_2, users_servers")) } ; (@ field_module ; access_token : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: access_token :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: message :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: message :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channel_messages :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_friends :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_friends :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; access_token $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: access_token :: Include :: $ selection_mode (crate :: prisma :: access_token :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; access_token $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: access_token :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: message_receiver :: Include :: $ selection_mode (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: message :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: message_receiver :: Include :: Fetch (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: message_sender :: Include :: $ selection_mode (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: message :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: message_sender :: Include :: Fetch (crate :: prisma :: message :: ManyArgs :: new (crate :: prisma :: message :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: text_channel_messages :: Include :: $ selection_mode (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channel_messages :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: text_channel_messages :: Include :: Fetch (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: friends_user_1 :: Include :: $ selection_mode (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_friends :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: friends_user_1 :: Include :: Fetch (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: friends_user_2 :: Include :: $ selection_mode (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_friends :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: friends_user_2 :: Include :: Fetch (crate :: prisma :: user_friends :: ManyArgs :: new (crate :: prisma :: user_friends :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: users_servers :: Include :: $ selection_mode (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: users_servers :: Include :: Fetch (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_name) => { "user_name" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; display_name) => { "display_name" } ; (@ field_serde_name ; first_name) => { "first_name" } ; (@ field_serde_name ; last_name) => { "last_name" } ; (@ field_serde_name ; image) => { "image" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; privacy_level) => { "privacy_level" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; access_token) => { "access_token" } ; (@ field_serde_name ; message_receiver) => { "message_receiver" } ; (@ field_serde_name ; message_sender) => { "message_sender" } ; (@ field_serde_name ; text_channel_messages) => { "text_channel_messages" } ; (@ field_serde_name ; friends_user_1) => { "friends_user_1" } ; (@ field_serde_name ; friends_user_2) => { "friends_user_2" } ; (@ field_serde_name ; users_servers) => { "users_servers" } ; }
    pub use _include_users as include;
    pub enum IncludeParam {
        Id(id::Include),
        UserName(user_name::Include),
        Password(password::Include),
        DisplayName(display_name::Include),
        FirstName(first_name::Include),
        LastName(last_name::Include),
        Image(image::Include),
        Status(status::Include),
        Email(email::Include),
        PrivacyLevel(privacy_level::Include),
        Role(role::Include),
        CreatedAt(created_at::Include),
        AccessToken(access_token::Include),
        MessageReceiver(message_receiver::Include),
        MessageSender(message_sender::Include),
        TextChannelMessages(text_channel_messages::Include),
        FriendsUser1(friends_user_1::Include),
        FriendsUser2(friends_user_2::Include),
        UsersServers(users_servers::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserName(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::FirstName(data) => data.to_selection(),
                Self::LastName(data) => data.to_selection(),
                Self::Image(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::PrivacyLevel(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::AccessToken(data) => data.to_selection(),
                Self::MessageReceiver(data) => data.to_selection(),
                Self::MessageSender(data) => data.to_selection(),
                Self::TextChannelMessages(data) => data.to_selection(),
                Self::FriendsUser1(data) => data.to_selection(),
                Self::FriendsUser2(data) => data.to_selection(),
                Self::UsersServers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_users { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: users struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "user_name")] user_name : String , # [serde (rename = "password")] password : String , # [serde (rename = "display_name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] display_name : Option < String > , # [serde (rename = "first_name")] first_name : String , # [serde (rename = "last_name")] last_name : String , # [serde (rename = "image")] image : String , # [serde (rename = "status")] status : crate :: prisma :: UsersStatus , # [serde (rename = "email")] email : String , # [serde (rename = "privacy_level")] privacy_level : crate :: prisma :: UsersPrivacyLevel , # [serde (rename = "role")] role : crate :: prisma :: UsersRole , # [serde (rename = "created_at")] created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_users as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "user_name")]
        pub user_name: String,
        #[serde(rename = "password")]
        pub password: String,
        #[serde(rename = "display_name")]
        pub display_name: Option<String>,
        #[serde(rename = "first_name")]
        pub first_name: String,
        #[serde(rename = "last_name")]
        pub last_name: String,
        #[serde(rename = "image")]
        pub image: String,
        #[serde(rename = "status")]
        pub status: super::UsersStatus,
        #[serde(rename = "email")]
        pub email: String,
        #[serde(rename = "privacy_level")]
        pub privacy_level: super::UsersPrivacyLevel,
        #[serde(rename = "role")]
        pub role: super::UsersRole,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(
            rename = "access_token",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub access_token: Option<Option<Box<super::access_token::Data>>>,
        #[serde(rename = "message_receiver")]
        pub message_receiver: Option<Vec<super::message::Data>>,
        #[serde(rename = "message_sender")]
        pub message_sender: Option<Vec<super::message::Data>>,
        #[serde(rename = "text_channel_messages")]
        pub text_channel_messages: Option<Vec<super::text_channel_messages::Data>>,
        #[serde(rename = "friends_user_1")]
        pub friends_user_1: Option<Vec<super::user_friends::Data>>,
        #[serde(rename = "friends_user_2")]
        pub friends_user_2: Option<Vec<super::user_friends::Data>>,
        #[serde(rename = "users_servers")]
        pub users_servers: Option<Vec<super::users_servers::Data>>,
    }
    impl Data {
        pub fn access_token(
            &self,
        ) -> Result<Option<&super::access_token::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.access_token
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(access_token),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn message_receiver(
            &self,
        ) -> Result<&Vec<super::message::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.message_receiver.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(message_receiver)),
            )
        }
        pub fn message_sender(
            &self,
        ) -> Result<&Vec<super::message::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.message_sender
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(message_sender),
                ))
        }
        pub fn text_channel_messages(
            &self,
        ) -> Result<
            &Vec<super::text_channel_messages::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.text_channel_messages.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    text_channel_messages
                )),
            )
        }
        pub fn friends_user_1(
            &self,
        ) -> Result<&Vec<super::user_friends::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.friends_user_1
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(friends_user_1),
                ))
        }
        pub fn friends_user_2(
            &self,
        ) -> Result<&Vec<super::user_friends::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.friends_user_2
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(friends_user_2),
                ))
        }
        pub fn users_servers(
            &self,
        ) -> Result<&Vec<super::users_servers::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.users_servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users_servers),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        AccessToken(super::access_token::UniqueArgs),
        MessageReceiver(super::message::ManyArgs),
        MessageSender(super::message::ManyArgs),
        TextChannelMessages(super::text_channel_messages::ManyArgs),
        FriendsUser1(super::user_friends::ManyArgs),
        FriendsUser2(super::user_friends::ManyArgs),
        UsersServers(super::users_servers::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::AccessToken(args) => {
                    let mut selections = < super :: access_token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(access_token::NAME, None, [], selections)
                }
                Self::MessageReceiver(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        message_receiver::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::MessageSender(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        message_sender::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::TextChannelMessages(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        text_channel_messages::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::FriendsUser1(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        friends_user_1::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::FriendsUser2(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        friends_user_2::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::UsersServers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        users_servers::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetUserName(String),
        SetPassword(String),
        SetDisplayName(Option<String>),
        SetFirstName(String),
        SetLastName(String),
        SetImage(String),
        SetStatus(super::UsersStatus),
        SetEmail(String),
        SetPrivacyLevel(super::UsersPrivacyLevel),
        SetRole(super::UsersRole),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ConnectAccessToken(super::access_token::UniqueWhereParam),
        DisconnectAccessToken,
        ConnectMessageReceiver(Vec<super::message::UniqueWhereParam>),
        DisconnectMessageReceiver(Vec<super::message::UniqueWhereParam>),
        SetMessageReceiver(Vec<super::message::UniqueWhereParam>),
        ConnectMessageSender(Vec<super::message::UniqueWhereParam>),
        DisconnectMessageSender(Vec<super::message::UniqueWhereParam>),
        SetMessageSender(Vec<super::message::UniqueWhereParam>),
        ConnectTextChannelMessages(Vec<super::text_channel_messages::UniqueWhereParam>),
        DisconnectTextChannelMessages(Vec<super::text_channel_messages::UniqueWhereParam>),
        SetTextChannelMessages(Vec<super::text_channel_messages::UniqueWhereParam>),
        ConnectFriendsUser1(Vec<super::user_friends::UniqueWhereParam>),
        DisconnectFriendsUser1(Vec<super::user_friends::UniqueWhereParam>),
        SetFriendsUser1(Vec<super::user_friends::UniqueWhereParam>),
        ConnectFriendsUser2(Vec<super::user_friends::UniqueWhereParam>),
        DisconnectFriendsUser2(Vec<super::user_friends::UniqueWhereParam>),
        SetFriendsUser2(Vec<super::user_friends::UniqueWhereParam>),
        ConnectUsersServers(Vec<super::users_servers::UniqueWhereParam>),
        DisconnectUsersServers(Vec<super::users_servers::UniqueWhereParam>),
        SetUsersServers(Vec<super::users_servers::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserName(value) => (
                    user_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPassword(value) => (
                    password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDisplayName(value) => (
                    display_name::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetFirstName(value) => (
                    first_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetLastName(value) => (
                    last_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetImage(value) => (
                    image::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetStatus(value) => (
                    status::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPrivacyLevel(value) => (
                    privacy_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetRole(value) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::ConnectAccessToken(where_param) => (
                    access_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::access_token::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectAccessToken => (
                    access_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectMessageReceiver(where_params) => (
                    message_receiver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::message::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectMessageReceiver(where_params) => (
                    message_receiver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::message::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMessageReceiver(where_params) => (
                    message_receiver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::message::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectMessageSender(where_params) => (
                    message_sender::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::message::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectMessageSender(where_params) => (
                    message_sender::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::message::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMessageSender(where_params) => (
                    message_sender::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::message::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectTextChannelMessages(where_params) => (
                    text_channel_messages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channel_messages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectTextChannelMessages(where_params) => (
                    text_channel_messages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channel_messages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTextChannelMessages(where_params) => (
                    text_channel_messages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channel_messages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFriendsUser1(where_params) => (
                    friends_user_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_friends::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFriendsUser1(where_params) => (
                    friends_user_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_friends::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFriendsUser1(where_params) => (
                    friends_user_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_friends::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFriendsUser2(where_params) => (
                    friends_user_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_friends::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFriendsUser2(where_params) => (
                    friends_user_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_friends::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFriendsUser2(where_params) => (
                    friends_user_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_friends::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsersServers(where_params) => (
                    users_servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUsersServers(where_params) => (
                    users_servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUsersServers(where_params) => (
                    users_servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        UserName(String),
        Password(String),
        DisplayName(Option<String>),
        FirstName(String),
        LastName(String),
        Image(String),
        Status(super::UsersStatus),
        Email(String),
        PrivacyLevel(super::UsersPrivacyLevel),
        Role(super::UsersRole),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::UserName(value) => Self::SetUserName(value),
                UncheckedSetParam::Password(value) => Self::SetPassword(value),
                UncheckedSetParam::DisplayName(value) => Self::SetDisplayName(value),
                UncheckedSetParam::FirstName(value) => Self::SetFirstName(value),
                UncheckedSetParam::LastName(value) => Self::SetLastName(value),
                UncheckedSetParam::Image(value) => Self::SetImage(value),
                UncheckedSetParam::Status(value) => Self::SetStatus(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::PrivacyLevel(value) => Self::SetPrivacyLevel(value),
                UncheckedSetParam::Role(value) => Self::SetRole(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        UserName(::prisma_client_rust::Direction),
        Password(::prisma_client_rust::Direction),
        DisplayName(::prisma_client_rust::Direction),
        FirstName(::prisma_client_rust::Direction),
        LastName(::prisma_client_rust::Direction),
        Image(::prisma_client_rust::Direction),
        Status(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        PrivacyLevel(::prisma_client_rust::Direction),
        Role(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserName(direction) => (
                    user_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Password(direction) => (
                    password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DisplayName(direction) => (
                    display_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FirstName(direction) => (
                    first_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LastName(direction) => (
                    last_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Image(direction) => (
                    image::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Status(direction) => (
                    status::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PrivacyLevel(direction) => (
                    privacy_level::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Role(direction) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        UserName(_prisma::read_filters::StringFilter),
        Password(_prisma::read_filters::StringFilter),
        DisplayName(_prisma::read_filters::StringNullableFilter),
        FirstName(_prisma::read_filters::StringFilter),
        LastName(_prisma::read_filters::StringFilter),
        Image(_prisma::read_filters::StringFilter),
        Status(_prisma::read_filters::users_statusFilter),
        Email(_prisma::read_filters::StringFilter),
        PrivacyLevel(_prisma::read_filters::users_privacy_levelFilter),
        Role(_prisma::read_filters::users_roleFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        AccessTokenIsNull,
        AccessTokenIs(Vec<super::access_token::WhereParam>),
        AccessTokenIsNot(Vec<super::access_token::WhereParam>),
        MessageReceiverSome(Vec<super::message::WhereParam>),
        MessageReceiverEvery(Vec<super::message::WhereParam>),
        MessageReceiverNone(Vec<super::message::WhereParam>),
        MessageSenderSome(Vec<super::message::WhereParam>),
        MessageSenderEvery(Vec<super::message::WhereParam>),
        MessageSenderNone(Vec<super::message::WhereParam>),
        TextChannelMessagesSome(Vec<super::text_channel_messages::WhereParam>),
        TextChannelMessagesEvery(Vec<super::text_channel_messages::WhereParam>),
        TextChannelMessagesNone(Vec<super::text_channel_messages::WhereParam>),
        FriendsUser1Some(Vec<super::user_friends::WhereParam>),
        FriendsUser1Every(Vec<super::user_friends::WhereParam>),
        FriendsUser1None(Vec<super::user_friends::WhereParam>),
        FriendsUser2Some(Vec<super::user_friends::WhereParam>),
        FriendsUser2Every(Vec<super::user_friends::WhereParam>),
        FriendsUser2None(Vec<super::user_friends::WhereParam>),
        UsersServersSome(Vec<super::users_servers::WhereParam>),
        UsersServersEvery(Vec<super::users_servers::WhereParam>),
        UsersServersNone(Vec<super::users_servers::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::UserName(value) => (user_name::NAME, value.into()),
                Self::Password(value) => (password::NAME, value.into()),
                Self::DisplayName(value) => (display_name::NAME, value.into()),
                Self::FirstName(value) => (first_name::NAME, value.into()),
                Self::LastName(value) => (last_name::NAME, value.into()),
                Self::Image(value) => (image::NAME, value.into()),
                Self::Status(value) => (status::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::PrivacyLevel(value) => (privacy_level::NAME, value.into()),
                Self::Role(value) => (role::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::AccessTokenIsNull => (
                    access_token::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::AccessTokenIs(where_params) => (
                    access_token::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::AccessTokenIsNot(where_params) => (
                    access_token::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageReceiverSome(where_params) => (
                    message_receiver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageReceiverEvery(where_params) => (
                    message_receiver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageReceiverNone(where_params) => (
                    message_receiver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageSenderSome(where_params) => (
                    message_sender::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageSenderEvery(where_params) => (
                    message_sender::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageSenderNone(where_params) => (
                    message_sender::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelMessagesSome(where_params) => (
                    text_channel_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelMessagesEvery(where_params) => (
                    text_channel_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelMessagesNone(where_params) => (
                    text_channel_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser1Some(where_params) => (
                    friends_user_1::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser1Every(where_params) => (
                    friends_user_1::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser1None(where_params) => (
                    friends_user_1::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser2Some(where_params) => (
                    friends_user_2::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser2Every(where_params) => (
                    friends_user_2::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser2None(where_params) => (
                    friends_user_2::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersSome(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersEvery(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersNone(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserNameEquals(String),
        EmailEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserNameEquals(value) => {
                    Self::UserName(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::EmailEquals(value) => {
                    Self::Email(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(user_name::NAME),
                ::prisma_client_rust::sel(password::NAME),
                ::prisma_client_rust::sel(display_name::NAME),
                ::prisma_client_rust::sel(first_name::NAME),
                ::prisma_client_rust::sel(last_name::NAME),
                ::prisma_client_rust::sel(image::NAME),
                ::prisma_client_rust::sel(status::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(privacy_level::NAME),
                ::prisma_client_rust::sel(role::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            user_name: String,
            password: String,
            first_name: String,
            last_name: String,
            image: String,
            status: super::UsersStatus,
            email: String,
            privacy_level: super::UsersPrivacyLevel,
            role: super::UsersRole,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_name::set(user_name),
                password::set(password),
                first_name::set(first_name),
                last_name::set(last_name),
                image::set(image),
                status::set(status),
                email::set(email),
                privacy_level::set(privacy_level),
                role::set(role),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_name: String,
            password: String,
            first_name: String,
            last_name: String,
            image: String,
            status: super::UsersStatus,
            email: String,
            privacy_level: super::UsersPrivacyLevel,
            role: super::UsersRole,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_name::set(user_name),
                password::set(password),
                first_name::set(first_name),
                last_name::set(last_name),
                image::set(image),
                status::set(status),
                email::set(email),
                privacy_level::set(privacy_level),
                role::set(role),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                String,
                String,
                String,
                String,
                String,
                super::UsersStatus,
                String,
                super::UsersPrivacyLevel,
                super::UsersRole,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(
                        user_name,
                        password,
                        first_name,
                        last_name,
                        image,
                        status,
                        email,
                        privacy_level,
                        role,
                        mut _params,
                    )| {
                        _params.extend([
                            user_name::set(user_name),
                            password::set(password),
                            first_name::set(first_name),
                            last_name::set(last_name),
                            image::set(image),
                            status::set(status),
                            email::set(email),
                            privacy_level::set(privacy_level),
                            role::set(role),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                user_name,
                password,
                first_name,
                last_name,
                image,
                status,
                email,
                privacy_level,
                role,
                mut _params,
            ): (
                String,
                String,
                String,
                String,
                String,
                super::UsersStatus,
                String,
                super::UsersPrivacyLevel,
                super::UsersRole,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                user_name::set(user_name),
                password::set(password),
                first_name::set(first_name),
                last_name::set(last_name),
                image::set(image),
                status::set(status),
                email::set(email),
                privacy_level::set(privacy_level),
                role::set(role),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod user_friends {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "user_friends";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_1_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_1_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUser1Id(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::User1Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::User1Id(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::User1Id(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, User1Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUser1Id(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUser1Id(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUser1Id(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUser1Id(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::User1Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::User1Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_2_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_2_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUser2Id(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::User2Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::User2Id(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::User2Id(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, User2Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUser2Id(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUser2Id(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUser2Id(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUser2Id(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::User2Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::User2Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod friends_user_1 {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "friends_user_1";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FriendsUser1(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFriendsUser1(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser1Is(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser1IsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FriendsUser1(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("friends_user_1", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FriendsUser1(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("friends_user_1", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod friends_user_2 {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "friends_user_2";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FriendsUser2(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFriendsUser2(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser2Is(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::FriendsUser2IsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FriendsUser2(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("friends_user_2", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FriendsUser2(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("friends_user_2", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        friends_user_1: super::users::UniqueWhereParam,
        friends_user_2: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        super::users::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (created_at, friends_user_1, friends_user_2, _params)
    }
    pub fn create_unchecked(
        user_1_id: i32,
        user_2_id: i32,
        created_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        i32,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (user_1_id, user_2_id, created_at, _params)
    }
    #[macro_export]
    macro_rules ! _select_user_friends { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user_friends :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_friends :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user_friends :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user_friends :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_friends :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user_friends :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , user_1_id , user_2_id , created_at , friends_user_1 , friends_user_2 } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: user_friends :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user_friends :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user_friends :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user_friends :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_friends :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_friends :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_1_id" , "user_2_id" , "created_at" , "friends_user_1" , "friends_user_2"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user_friends :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; user_1_id) => { i32 } ; (@ field_type ; user_2_id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { friends_user_1 :: Data } ; (@ field_type ; friends_user_1) => { crate :: prisma :: users :: Data } ; (@ field_type ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { friends_user_2 :: Data } ; (@ field_type ; friends_user_2) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UserFriends" , available relations are "id, user_1_id, user_2_id, created_at, friends_user_1, friends_user_2")) } ; (@ field_module ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: id :: Select) } ; (@ selection_field_to_selection_param ; user_1_id) => { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: user_1_id :: Select) } ; (@ selection_field_to_selection_param ; user_2_id) => { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: user_2_id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: created_at :: Select) } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: friends_user_1 :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: friends_user_1 :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: friends_user_2 :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_friends :: SelectParam > :: into (crate :: prisma :: user_friends :: friends_user_2 :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user_friends :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_1_id) => { "user_1_id" } ; (@ field_serde_name ; user_2_id) => { "user_2_id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; friends_user_1) => { "friends_user_1" } ; (@ field_serde_name ; friends_user_2) => { "friends_user_2" } ; }
    pub use _select_user_friends as select;
    pub enum SelectParam {
        Id(id::Select),
        User1Id(user_1_id::Select),
        User2Id(user_2_id::Select),
        CreatedAt(created_at::Select),
        FriendsUser1(friends_user_1::Select),
        FriendsUser2(friends_user_2::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::User1Id(data) => data.to_selection(),
                Self::User2Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::FriendsUser1(data) => data.to_selection(),
                Self::FriendsUser2(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user_friends { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user_friends :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_friends :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user_friends :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user_friends :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_friends :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user_friends :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user_friends :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { friends_user_1 , friends_user_2 } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub user_1_id : i32 , pub user_2_id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: user_friends :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_1_id) , stringify ! (user_2_id) , stringify ! (created_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user_friends :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: user_friends :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: user_friends :: user_1_id :: NAME , & self . user_1_id) ? ; state . serialize_field (crate :: prisma :: user_friends :: user_2_id :: NAME , & self . user_2_id) ? ; state . serialize_field (crate :: prisma :: user_friends :: created_at :: NAME , & self . created_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , user_1_id , user_2_id , created_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user_friends :: $ field :: NAME) , + , crate :: prisma :: user_friends :: id :: NAME , crate :: prisma :: user_friends :: user_1_id :: NAME , crate :: prisma :: user_friends :: user_2_id :: NAME , crate :: prisma :: user_friends :: created_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user_friends :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: user_friends :: id :: NAME => Ok (Field :: id) , crate :: prisma :: user_friends :: user_1_id :: NAME => Ok (Field :: user_1_id) , crate :: prisma :: user_friends :: user_2_id :: NAME => Ok (Field :: user_2_id) , crate :: prisma :: user_friends :: created_at :: NAME => Ok (Field :: created_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut user_1_id = None ; let mut user_2_id = None ; let mut created_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_friends :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: user_1_id => { if user_1_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_friends :: user_1_id :: NAME)) ; } user_1_id = Some (map . next_value () ?) ; } Field :: user_2_id => { if user_2_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_friends :: user_2_id :: NAME)) ; } user_2_id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_friends :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_friends :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_friends :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_friends :: id :: NAME)) ? ; let user_1_id = user_1_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_friends :: user_1_id :: NAME)) ? ; let user_2_id = user_2_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_friends :: user_2_id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_friends :: created_at :: NAME)) ? ; Ok (Data { id , user_1_id , user_2_id , created_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_1_id" , "user_2_id" , "created_at" , "friends_user_1" , "friends_user_2"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user_friends :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { friends_user_1 :: Data } ; (@ field_type ; friends_user_1) => { crate :: prisma :: users :: Data } ; (@ field_type ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { friends_user_2 :: Data } ; (@ field_type ; friends_user_2) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UserFriends" , available relations are "friends_user_1, friends_user_2")) } ; (@ field_module ; friends_user_1 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; friends_user_2 : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_friends :: IncludeParam > :: into (crate :: prisma :: user_friends :: friends_user_1 :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_1 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_friends :: IncludeParam > :: into (crate :: prisma :: user_friends :: friends_user_1 :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_friends :: IncludeParam > :: into (crate :: prisma :: user_friends :: friends_user_2 :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; friends_user_2 $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_friends :: IncludeParam > :: into (crate :: prisma :: user_friends :: friends_user_2 :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user_friends :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_1_id) => { "user_1_id" } ; (@ field_serde_name ; user_2_id) => { "user_2_id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; friends_user_1) => { "friends_user_1" } ; (@ field_serde_name ; friends_user_2) => { "friends_user_2" } ; }
    pub use _include_user_friends as include;
    pub enum IncludeParam {
        Id(id::Include),
        User1Id(user_1_id::Include),
        User2Id(user_2_id::Include),
        CreatedAt(created_at::Include),
        FriendsUser1(friends_user_1::Include),
        FriendsUser2(friends_user_2::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::User1Id(data) => data.to_selection(),
                Self::User2Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::FriendsUser1(data) => data.to_selection(),
                Self::FriendsUser2(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_user_friends { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: user_friends struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "user_1_id")] user_1_id : i32 , # [serde (rename = "user_2_id")] user_2_id : i32 , # [serde (rename = "created_at")] created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_user_friends as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "user_1_id")]
        pub user_1_id: i32,
        #[serde(rename = "user_2_id")]
        pub user_2_id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "friends_user_1")]
        pub friends_user_1: Option<Box<super::users::Data>>,
        #[serde(rename = "friends_user_2")]
        pub friends_user_2: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn friends_user_1(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.friends_user_1
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(friends_user_1),
                ))
                .map(|v| v.as_ref())
        }
        pub fn friends_user_2(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.friends_user_2
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(friends_user_2),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        FriendsUser1(super::users::UniqueArgs),
        FriendsUser2(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::FriendsUser1(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(friends_user_1::NAME, None, [], selections)
                }
                Self::FriendsUser2(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(friends_user_2::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetUser1Id(i32),
        IncrementUser1Id(i32),
        DecrementUser1Id(i32),
        MultiplyUser1Id(i32),
        DivideUser1Id(i32),
        SetUser2Id(i32),
        IncrementUser2Id(i32),
        DecrementUser2Id(i32),
        MultiplyUser2Id(i32),
        DivideUser2Id(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ConnectFriendsUser1(super::users::UniqueWhereParam),
        ConnectFriendsUser2(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUser1Id(value) => (
                    user_1_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUser1Id(value) => (
                    user_1_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUser1Id(value) => (
                    user_1_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUser1Id(value) => (
                    user_1_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUser1Id(value) => (
                    user_1_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUser2Id(value) => (
                    user_2_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUser2Id(value) => (
                    user_2_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUser2Id(value) => (
                    user_2_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUser2Id(value) => (
                    user_2_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUser2Id(value) => (
                    user_2_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::ConnectFriendsUser1(where_param) => (
                    friends_user_1::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFriendsUser2(where_param) => (
                    friends_user_2::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        User1Id(i32),
        User2Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::User1Id(value) => Self::SetUser1Id(value),
                UncheckedSetParam::User2Id(value) => Self::SetUser2Id(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        User1Id(::prisma_client_rust::Direction),
        User2Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::User1Id(direction) => (
                    user_1_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::User2Id(direction) => (
                    user_2_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        User1Id(_prisma::read_filters::IntFilter),
        User2Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        FriendsUser1Is(Vec<super::users::WhereParam>),
        FriendsUser1IsNot(Vec<super::users::WhereParam>),
        FriendsUser2Is(Vec<super::users::WhereParam>),
        FriendsUser2IsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::User1Id(value) => (user_1_id::NAME, value.into()),
                Self::User2Id(value) => (user_2_id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::FriendsUser1Is(where_params) => (
                    friends_user_1::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser1IsNot(where_params) => (
                    friends_user_1::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser2Is(where_params) => (
                    friends_user_2::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FriendsUser2IsNot(where_params) => (
                    friends_user_2::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(user_1_id::NAME),
                ::prisma_client_rust::sel(user_2_id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            friends_user_1: super::users::UniqueWhereParam,
            friends_user_2: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                created_at::set(created_at),
                friends_user_1::connect(friends_user_1),
                friends_user_2::connect(friends_user_2),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_1_id: i32,
            user_2_id: i32,
            created_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_1_id::set(user_1_id),
                user_2_id::set(user_2_id),
                created_at::set(created_at),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                i32,
                i32,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_1_id, user_2_id, created_at, mut _params)| {
                    _params.extend([
                        user_1_id::set(user_1_id),
                        user_2_id::set(user_2_id),
                        created_at::set(created_at),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (created_at, friends_user_1, friends_user_2, mut _params): (
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                super::users::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                created_at::set(created_at),
                friends_user_1::connect(friends_user_1),
                friends_user_2::connect(friends_user_2),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod message {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "message";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod sender_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "sender_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSenderId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SenderId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SenderId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SenderId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SenderId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSenderId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSenderId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySenderId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSenderId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SenderId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SenderId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod receiver_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "receiver_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetReceiverId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ReceiverId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReceiverId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ReceiverId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ReceiverId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementReceiverId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementReceiverId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyReceiverId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideReceiverId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReceiverId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReceiverId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod r#type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "type";
        pub struct Set(pub self::MessageType);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Type(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::MessageType) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Type(direction)
        }
        pub fn equals(value: self::MessageType) -> WhereParam {
            WhereParam::Type(_prisma::read_filters::message_typeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::message_typeFilter,
            Type,
            {
                fn in_vec(_: Vec<super::super::MessageType>) -> InVec;
                fn not_in_vec(_: Vec<super::super::MessageType>) -> NotInVec;
                fn not(_: super::super::MessageType) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Type(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Type(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod payload {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "payload";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPayload(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Payload(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Payload(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Payload(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Payload,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Payload(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Payload(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod deleted_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "deleted_at";
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDeletedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DeletedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DeletedAt(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::DeletedAt(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeNullableFilter,
            DeletedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: Option<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DeletedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DeletedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod message_receiver {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "message_receiver";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::MessageReceiver(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMessageReceiver(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::MessageReceiverIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::MessageReceiverIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageReceiver(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("message_receiver", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageReceiver(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("message_receiver", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod message_sender {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "message_sender";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::MessageSender(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMessageSender(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::MessageSenderIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::MessageSenderIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageSender(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("message_sender", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageSender(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("message_sender", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        r#type: super::MessageType,
        payload: String,
        message_receiver: super::users::UniqueWhereParam,
        message_sender: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::MessageType,
        String,
        super::users::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (r#type, payload, message_receiver, message_sender, _params)
    }
    pub fn create_unchecked(
        sender_id: i32,
        receiver_id: i32,
        r#type: super::MessageType,
        payload: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, super::MessageType, String, Vec<SetParam>) {
        (sender_id, receiver_id, r#type, payload, _params)
    }
    #[macro_export]
    macro_rules ! _select_message { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: message :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: message :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: message :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: message :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: message :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: message :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , sender_id , receiver_id , r#type , payload , created_at , deleted_at , message_receiver , message_sender } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: message :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: message :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: message :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: message :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "sender_id" , "receiver_id" , "type" , "payload" , "created_at" , "deleted_at" , "message_receiver" , "message_sender"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: message :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; sender_id) => { i32 } ; (@ field_type ; receiver_id) => { i32 } ; (@ field_type ; r#type) => { crate :: prisma :: MessageType } ; (@ field_type ; payload) => { String } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; deleted_at) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { message_receiver :: Data } ; (@ field_type ; message_receiver) => { crate :: prisma :: users :: Data } ; (@ field_type ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { message_sender :: Data } ; (@ field_type ; message_sender) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Message" , available relations are "id, sender_id, receiver_id, r#type, payload, created_at, deleted_at, message_receiver, message_sender")) } ; (@ field_module ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: id :: Select) } ; (@ selection_field_to_selection_param ; sender_id) => { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: sender_id :: Select) } ; (@ selection_field_to_selection_param ; receiver_id) => { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: receiver_id :: Select) } ; (@ selection_field_to_selection_param ; r#type) => { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: r#type :: Select) } ; (@ selection_field_to_selection_param ; payload) => { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: payload :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: created_at :: Select) } ; (@ selection_field_to_selection_param ; deleted_at) => { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: deleted_at :: Select) } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: message_receiver :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: message_receiver :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: message_sender :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: message :: SelectParam > :: into (crate :: prisma :: message :: message_sender :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: message :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; sender_id) => { "sender_id" } ; (@ field_serde_name ; receiver_id) => { "receiver_id" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; payload) => { "payload" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; deleted_at) => { "deleted_at" } ; (@ field_serde_name ; message_receiver) => { "message_receiver" } ; (@ field_serde_name ; message_sender) => { "message_sender" } ; }
    pub use _select_message as select;
    pub enum SelectParam {
        Id(id::Select),
        SenderId(sender_id::Select),
        ReceiverId(receiver_id::Select),
        Type(r#type::Select),
        Payload(payload::Select),
        CreatedAt(created_at::Select),
        DeletedAt(deleted_at::Select),
        MessageReceiver(message_receiver::Select),
        MessageSender(message_sender::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SenderId(data) => data.to_selection(),
                Self::ReceiverId(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::Payload(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::DeletedAt(data) => data.to_selection(),
                Self::MessageReceiver(data) => data.to_selection(),
                Self::MessageSender(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_message { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: message :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: message :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: message :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: message :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: message :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: message :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: message :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { message_receiver , message_sender } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub sender_id : i32 , pub receiver_id : i32 , pub r#type : crate :: prisma :: MessageType , pub payload : String , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub deleted_at : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : crate :: prisma :: message :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (sender_id) , stringify ! (receiver_id) , stringify ! (r#type) , stringify ! (payload) , stringify ! (created_at) , stringify ! (deleted_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: message :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: message :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: message :: sender_id :: NAME , & self . sender_id) ? ; state . serialize_field (crate :: prisma :: message :: receiver_id :: NAME , & self . receiver_id) ? ; state . serialize_field (crate :: prisma :: message :: r#type :: NAME , & self . r#type) ? ; state . serialize_field (crate :: prisma :: message :: payload :: NAME , & self . payload) ? ; state . serialize_field (crate :: prisma :: message :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: message :: deleted_at :: NAME , & self . deleted_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , sender_id , receiver_id , r#type , payload , created_at , deleted_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: message :: $ field :: NAME) , + , crate :: prisma :: message :: id :: NAME , crate :: prisma :: message :: sender_id :: NAME , crate :: prisma :: message :: receiver_id :: NAME , crate :: prisma :: message :: r#type :: NAME , crate :: prisma :: message :: payload :: NAME , crate :: prisma :: message :: created_at :: NAME , crate :: prisma :: message :: deleted_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: message :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: message :: id :: NAME => Ok (Field :: id) , crate :: prisma :: message :: sender_id :: NAME => Ok (Field :: sender_id) , crate :: prisma :: message :: receiver_id :: NAME => Ok (Field :: receiver_id) , crate :: prisma :: message :: r#type :: NAME => Ok (Field :: r#type) , crate :: prisma :: message :: payload :: NAME => Ok (Field :: payload) , crate :: prisma :: message :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: message :: deleted_at :: NAME => Ok (Field :: deleted_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut sender_id = None ; let mut receiver_id = None ; let mut r#type = None ; let mut payload = None ; let mut created_at = None ; let mut deleted_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: sender_id => { if sender_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: sender_id :: NAME)) ; } sender_id = Some (map . next_value () ?) ; } Field :: receiver_id => { if receiver_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: receiver_id :: NAME)) ; } receiver_id = Some (map . next_value () ?) ; } Field :: r#type => { if r#type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: r#type :: NAME)) ; } r#type = Some (map . next_value () ?) ; } Field :: payload => { if payload . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: payload :: NAME)) ; } payload = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: deleted_at => { if deleted_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: deleted_at :: NAME)) ; } deleted_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: message :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: id :: NAME)) ? ; let sender_id = sender_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: sender_id :: NAME)) ? ; let receiver_id = receiver_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: receiver_id :: NAME)) ? ; let r#type = r#type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: r#type :: NAME)) ? ; let payload = payload . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: payload :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: created_at :: NAME)) ? ; let deleted_at = deleted_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: message :: deleted_at :: NAME)) ? ; Ok (Data { id , sender_id , receiver_id , r#type , payload , created_at , deleted_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "sender_id" , "receiver_id" , "type" , "payload" , "created_at" , "deleted_at" , "message_receiver" , "message_sender"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: message :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { message_receiver :: Data } ; (@ field_type ; message_receiver) => { crate :: prisma :: users :: Data } ; (@ field_type ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { message_sender :: Data } ; (@ field_type ; message_sender) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Message" , available relations are "message_receiver, message_sender")) } ; (@ field_module ; message_receiver : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; message_sender : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: message :: IncludeParam > :: into (crate :: prisma :: message :: message_receiver :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_receiver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: message :: IncludeParam > :: into (crate :: prisma :: message :: message_receiver :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: message :: IncludeParam > :: into (crate :: prisma :: message :: message_sender :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; message_sender $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: message :: IncludeParam > :: into (crate :: prisma :: message :: message_sender :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: message :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; sender_id) => { "sender_id" } ; (@ field_serde_name ; receiver_id) => { "receiver_id" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; payload) => { "payload" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; deleted_at) => { "deleted_at" } ; (@ field_serde_name ; message_receiver) => { "message_receiver" } ; (@ field_serde_name ; message_sender) => { "message_sender" } ; }
    pub use _include_message as include;
    pub enum IncludeParam {
        Id(id::Include),
        SenderId(sender_id::Include),
        ReceiverId(receiver_id::Include),
        Type(r#type::Include),
        Payload(payload::Include),
        CreatedAt(created_at::Include),
        DeletedAt(deleted_at::Include),
        MessageReceiver(message_receiver::Include),
        MessageSender(message_sender::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SenderId(data) => data.to_selection(),
                Self::ReceiverId(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::Payload(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::DeletedAt(data) => data.to_selection(),
                Self::MessageReceiver(data) => data.to_selection(),
                Self::MessageSender(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_message { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: message struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "sender_id")] sender_id : i32 , # [serde (rename = "receiver_id")] receiver_id : i32 , # [serde (rename = "type")] r#type : crate :: prisma :: MessageType , # [serde (rename = "payload")] payload : String , # [serde (rename = "created_at")] created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "deleted_at")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] deleted_at : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_message as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "sender_id")]
        pub sender_id: i32,
        #[serde(rename = "receiver_id")]
        pub receiver_id: i32,
        #[serde(rename = "type")]
        pub r#type: super::MessageType,
        #[serde(rename = "payload")]
        pub payload: String,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "deleted_at")]
        pub deleted_at: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "message_receiver")]
        pub message_receiver: Option<Box<super::users::Data>>,
        #[serde(rename = "message_sender")]
        pub message_sender: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn message_receiver(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.message_receiver
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(message_receiver),
                ))
                .map(|v| v.as_ref())
        }
        pub fn message_sender(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.message_sender
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(message_sender),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        MessageReceiver(super::users::UniqueArgs),
        MessageSender(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MessageReceiver(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        message_receiver::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                Self::MessageSender(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(message_sender::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSenderId(i32),
        IncrementSenderId(i32),
        DecrementSenderId(i32),
        MultiplySenderId(i32),
        DivideSenderId(i32),
        SetReceiverId(i32),
        IncrementReceiverId(i32),
        DecrementReceiverId(i32),
        MultiplyReceiverId(i32),
        DivideReceiverId(i32),
        SetType(super::MessageType),
        SetPayload(String),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetDeletedAt(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        ConnectMessageReceiver(super::users::UniqueWhereParam),
        ConnectMessageSender(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetReceiverId(value) => (
                    receiver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementReceiverId(value) => (
                    receiver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementReceiverId(value) => (
                    receiver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyReceiverId(value) => (
                    receiver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideReceiverId(value) => (
                    receiver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetType(value) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetPayload(value) => (
                    payload::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetDeletedAt(value) => (
                    deleted_at::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectMessageReceiver(where_param) => (
                    message_receiver::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectMessageSender(where_param) => (
                    message_sender::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SenderId(i32),
        ReceiverId(i32),
        Type(super::MessageType),
        Payload(String),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        DeletedAt(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SenderId(value) => Self::SetSenderId(value),
                UncheckedSetParam::ReceiverId(value) => Self::SetReceiverId(value),
                UncheckedSetParam::Type(value) => Self::SetType(value),
                UncheckedSetParam::Payload(value) => Self::SetPayload(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::DeletedAt(value) => Self::SetDeletedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SenderId(::prisma_client_rust::Direction),
        ReceiverId(::prisma_client_rust::Direction),
        Type(::prisma_client_rust::Direction),
        Payload(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        DeletedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SenderId(direction) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReceiverId(direction) => (
                    receiver_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Type(direction) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Payload(direction) => (
                    payload::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DeletedAt(direction) => (
                    deleted_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        SenderId(_prisma::read_filters::IntFilter),
        ReceiverId(_prisma::read_filters::IntFilter),
        Type(_prisma::read_filters::message_typeFilter),
        Payload(_prisma::read_filters::StringFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        DeletedAt(_prisma::read_filters::DateTimeNullableFilter),
        MessageReceiverIs(Vec<super::users::WhereParam>),
        MessageReceiverIsNot(Vec<super::users::WhereParam>),
        MessageSenderIs(Vec<super::users::WhereParam>),
        MessageSenderIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SenderId(value) => (sender_id::NAME, value.into()),
                Self::ReceiverId(value) => (receiver_id::NAME, value.into()),
                Self::Type(value) => (r#type::NAME, value.into()),
                Self::Payload(value) => (payload::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::DeletedAt(value) => (deleted_at::NAME, value.into()),
                Self::MessageReceiverIs(where_params) => (
                    message_receiver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageReceiverIsNot(where_params) => (
                    message_receiver::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageSenderIs(where_params) => (
                    message_sender::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MessageSenderIsNot(where_params) => (
                    message_sender::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(sender_id::NAME),
                ::prisma_client_rust::sel(receiver_id::NAME),
                ::prisma_client_rust::sel(r#type::NAME),
                ::prisma_client_rust::sel(payload::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(deleted_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            r#type: super::MessageType,
            payload: String,
            message_receiver: super::users::UniqueWhereParam,
            message_sender: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                r#type::set(r#type),
                payload::set(payload),
                message_receiver::connect(message_receiver),
                message_sender::connect(message_sender),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            sender_id: i32,
            receiver_id: i32,
            r#type: super::MessageType,
            payload: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                sender_id::set(sender_id),
                receiver_id::set(receiver_id),
                r#type::set(r#type),
                payload::set(payload),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, super::MessageType, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(sender_id, receiver_id, r#type, payload, mut _params)| {
                    _params.extend([
                        sender_id::set(sender_id),
                        receiver_id::set(receiver_id),
                        r#type::set(r#type),
                        payload::set(payload),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (r#type, payload, message_receiver, message_sender, mut _params): (
                super::MessageType,
                String,
                super::users::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                r#type::set(r#type),
                payload::set(payload),
                message_receiver::connect(message_receiver),
                message_sender::connect(message_sender),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod access_token {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "access_token";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::UserIdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod access_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "access_token";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAccessToken(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AccessToken(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AccessToken(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::AccessToken(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            AccessToken,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AccessToken(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AccessToken(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod refresh_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "refresh_token";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRefreshToken(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RefreshToken(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RefreshToken(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::RefreshToken(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            RefreshToken,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RefreshToken(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RefreshToken(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        access_token: String,
        refresh_token: String,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (access_token, refresh_token, users, _params)
    }
    pub fn create_unchecked(
        user_id: i32,
        access_token: String,
        refresh_token: String,
        _params: Vec<SetParam>,
    ) -> (i32, String, String, Vec<SetParam>) {
        (user_id, access_token, refresh_token, _params)
    }
    #[macro_export]
    macro_rules ! _select_access_token { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: access_token :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: access_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: access_token :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: access_token :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: access_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: access_token :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , user_id , access_token , refresh_token , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: access_token :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: access_token :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: access_token :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: access_token :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: access_token :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: access_token :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "access_token" , "refresh_token" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: access_token :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; access_token) => { String } ; (@ field_type ; refresh_token) => { String } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "AccessToken" , available relations are "id, user_id, access_token, refresh_token, users")) } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: access_token :: SelectParam > :: into (crate :: prisma :: access_token :: id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: access_token :: SelectParam > :: into (crate :: prisma :: access_token :: user_id :: Select) } ; (@ selection_field_to_selection_param ; access_token) => { Into :: < crate :: prisma :: access_token :: SelectParam > :: into (crate :: prisma :: access_token :: access_token :: Select) } ; (@ selection_field_to_selection_param ; refresh_token) => { Into :: < crate :: prisma :: access_token :: SelectParam > :: into (crate :: prisma :: access_token :: refresh_token :: Select) } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: access_token :: SelectParam > :: into (crate :: prisma :: access_token :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: access_token :: SelectParam > :: into (crate :: prisma :: access_token :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: access_token :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; access_token) => { "access_token" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_access_token as select;
    pub enum SelectParam {
        Id(id::Select),
        UserId(user_id::Select),
        AccessToken(access_token::Select),
        RefreshToken(refresh_token::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::AccessToken(data) => data.to_selection(),
                Self::RefreshToken(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_access_token { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: access_token :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: access_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: access_token :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: access_token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: access_token :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: access_token :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: access_token :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: access_token :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub user_id : i32 , pub access_token : String , pub refresh_token : String , $ (pub $ field : crate :: prisma :: access_token :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_id) , stringify ! (access_token) , stringify ! (refresh_token)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: access_token :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: access_token :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: access_token :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: access_token :: access_token :: NAME , & self . access_token) ? ; state . serialize_field (crate :: prisma :: access_token :: refresh_token :: NAME , & self . refresh_token) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , user_id , access_token , refresh_token } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: access_token :: $ field :: NAME) , + , crate :: prisma :: access_token :: id :: NAME , crate :: prisma :: access_token :: user_id :: NAME , crate :: prisma :: access_token :: access_token :: NAME , crate :: prisma :: access_token :: refresh_token :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: access_token :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: access_token :: id :: NAME => Ok (Field :: id) , crate :: prisma :: access_token :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: access_token :: access_token :: NAME => Ok (Field :: access_token) , crate :: prisma :: access_token :: refresh_token :: NAME => Ok (Field :: refresh_token) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut user_id = None ; let mut access_token = None ; let mut refresh_token = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: access_token :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: access_token :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: access_token => { if access_token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: access_token :: access_token :: NAME)) ; } access_token = Some (map . next_value () ?) ; } Field :: refresh_token => { if refresh_token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: access_token :: refresh_token :: NAME)) ; } refresh_token = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: access_token :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: access_token :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: access_token :: id :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: access_token :: user_id :: NAME)) ? ; let access_token = access_token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: access_token :: access_token :: NAME)) ? ; let refresh_token = refresh_token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: access_token :: refresh_token :: NAME)) ? ; Ok (Data { id , user_id , access_token , refresh_token , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "access_token" , "refresh_token" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: access_token :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "AccessToken" , available relations are "users")) } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: access_token :: IncludeParam > :: into (crate :: prisma :: access_token :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: access_token :: IncludeParam > :: into (crate :: prisma :: access_token :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: access_token :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; access_token) => { "access_token" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_access_token as include;
    pub enum IncludeParam {
        Id(id::Include),
        UserId(user_id::Include),
        AccessToken(access_token::Include),
        RefreshToken(refresh_token::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::AccessToken(data) => data.to_selection(),
                Self::RefreshToken(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_access_token { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: access_token struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "user_id")] user_id : i32 , # [serde (rename = "access_token")] access_token : String , # [serde (rename = "refresh_token")] refresh_token : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_access_token as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "access_token")]
        pub access_token: String,
        #[serde(rename = "refresh_token")]
        pub refresh_token: String,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        SetAccessToken(String),
        SetRefreshToken(String),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetAccessToken(value) => (
                    access_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetRefreshToken(value) => (
                    refresh_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        UserId(i32),
        AccessToken(String),
        RefreshToken(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::AccessToken(value) => Self::SetAccessToken(value),
                UncheckedSetParam::RefreshToken(value) => Self::SetRefreshToken(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        AccessToken(::prisma_client_rust::Direction),
        RefreshToken(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AccessToken(direction) => (
                    access_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RefreshToken(direction) => (
                    refresh_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        UserId(_prisma::read_filters::IntFilter),
        AccessToken(_prisma::read_filters::StringFilter),
        RefreshToken(_prisma::read_filters::StringFilter),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::AccessToken(value) => (access_token::NAME, value.into()),
                Self::RefreshToken(value) => (refresh_token::NAME, value.into()),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdEquals(i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdEquals(value) => {
                    Self::UserId(_prisma::read_filters::IntFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(access_token::NAME),
                ::prisma_client_rust::sel(refresh_token::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            access_token: String,
            refresh_token: String,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                access_token::set(access_token),
                refresh_token::set(refresh_token),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_id: i32,
            access_token: String,
            refresh_token: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_id::set(user_id),
                access_token::set(access_token),
                refresh_token::set(refresh_token),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, access_token, refresh_token, mut _params)| {
                    _params.extend([
                        user_id::set(user_id),
                        access_token::set(access_token),
                        refresh_token::set(refresh_token),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (access_token, refresh_token, users, mut _params): (
                String,
                String,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                access_token::set(access_token),
                refresh_token::set(refresh_token),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod users_servers {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "users_servers";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod server_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetServerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ServerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ServerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ServerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ServerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementServerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementServerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyServerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideServerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod display_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "display_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDisplayName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DisplayName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DisplayName(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DisplayName(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            DisplayName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DisplayName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DisplayName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "role";
        pub struct Set(pub self::ServerRole);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRole(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Role(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::ServerRole) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub fn equals(value: self::ServerRole) -> WhereParam {
            WhereParam::Role(_prisma::read_filters::server_roleFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::server_roleFilter,
            Role,
            {
                fn in_vec(_: Vec<super::super::ServerRole>) -> InVec;
                fn not_in_vec(_: Vec<super::super::ServerRole>) -> NotInVec;
                fn not(_: super::super::ServerRole) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Role(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Role(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_server_tags {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_server_tags";
        pub struct Fetch(pub user_server_tags::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user_server_tags::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user_server_tags::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: user_server_tags::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UserServerTags(v)
            }
        }
        pub fn fetch(params: Vec<user_server_tags::WhereParam>) -> Fetch {
            Fetch(user_server_tags::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<user_server_tags::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUserServerTags(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<user_server_tags::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<user_server_tags::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUserServerTags(params)
        }
        pub fn set(params: Vec<user_server_tags::UniqueWhereParam>) -> SetParam {
            SetParam::SetUserServerTags(params)
        }
        pub fn some(value: Vec<user_server_tags::WhereParam>) -> WhereParam {
            WhereParam::UserServerTagsSome(value)
        }
        pub fn every(value: Vec<user_server_tags::WhereParam>) -> WhereParam {
            WhereParam::UserServerTagsEvery(value)
        }
        pub fn none(value: Vec<user_server_tags::WhereParam>) -> WhereParam {
            WhereParam::UserServerTagsNone(value)
        }
        pub enum Include {
            Select(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::SelectParam>,
            ),
            Include(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::IncludeParam>,
            ),
            Fetch(user_server_tags::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserServerTags(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::SelectParam>,
            ),
            Include(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::IncludeParam>,
            ),
            Fetch(user_server_tags::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserServerTags(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "servers";
        pub struct Fetch(pub servers::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Servers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(servers::UniqueArgs::new())
        }
        pub struct Connect(servers::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: servers::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIs(value)
        }
        pub fn is_not(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIsNot(value)
        }
        pub enum Include {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Servers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Servers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        display_name: String,
        role: super::ServerRole,
        servers: super::servers::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        super::ServerRole,
        super::servers::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (display_name, role, servers, users, _params)
    }
    pub fn create_unchecked(
        user_id: i32,
        server_id: i32,
        display_name: String,
        role: super::ServerRole,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, super::ServerRole, Vec<SetParam>) {
        (user_id, server_id, display_name, role, _params)
    }
    #[macro_export]
    macro_rules ! _select_users_servers { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users_servers :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users_servers :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , user_id , server_id , display_name , role , user_server_tags , servers , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: users_servers :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users_servers :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users_servers :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users_servers :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_servers :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_servers :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "server_id" , "display_name" , "role" , "user_server_tags" , "servers" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users_servers :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; server_id) => { i32 } ; (@ field_type ; display_name) => { String } ; (@ field_type ; role) => { crate :: prisma :: ServerRole } ; (@ field_type ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user_server_tags :: Data > } ; (@ field_type ; user_server_tags) => { Vec < crate :: prisma :: user_server_tags :: Data > } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UsersServers" , available relations are "id, user_id, server_id, display_name, role, user_server_tags, servers, users")) } ; (@ field_module ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_server_tags :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: user_id :: Select) } ; (@ selection_field_to_selection_param ; server_id) => { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: server_id :: Select) } ; (@ selection_field_to_selection_param ; display_name) => { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: display_name :: Select) } ; (@ selection_field_to_selection_param ; role) => { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: role :: Select) } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: user_server_tags :: Select :: $ selection_mode (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: user_server_tags :: Select :: Fetch (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: servers :: Select :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: servers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_servers :: SelectParam > :: into (crate :: prisma :: users_servers :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users_servers :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; display_name) => { "display_name" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; user_server_tags) => { "user_server_tags" } ; (@ field_serde_name ; servers) => { "servers" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_users_servers as select;
    pub enum SelectParam {
        Id(id::Select),
        UserId(user_id::Select),
        ServerId(server_id::Select),
        DisplayName(display_name::Select),
        Role(role::Select),
        UserServerTags(user_server_tags::Select),
        Servers(servers::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::UserServerTags(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_users_servers { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users_servers :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users_servers :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users_servers :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users_servers :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_server_tags , servers , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub user_id : i32 , pub server_id : i32 , pub display_name : String , pub role : crate :: prisma :: ServerRole , $ (pub $ field : crate :: prisma :: users_servers :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (user_id) , stringify ! (server_id) , stringify ! (display_name) , stringify ! (role)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users_servers :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: users_servers :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: users_servers :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: users_servers :: server_id :: NAME , & self . server_id) ? ; state . serialize_field (crate :: prisma :: users_servers :: display_name :: NAME , & self . display_name) ? ; state . serialize_field (crate :: prisma :: users_servers :: role :: NAME , & self . role) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , user_id , server_id , display_name , role } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users_servers :: $ field :: NAME) , + , crate :: prisma :: users_servers :: id :: NAME , crate :: prisma :: users_servers :: user_id :: NAME , crate :: prisma :: users_servers :: server_id :: NAME , crate :: prisma :: users_servers :: display_name :: NAME , crate :: prisma :: users_servers :: role :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users_servers :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: users_servers :: id :: NAME => Ok (Field :: id) , crate :: prisma :: users_servers :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: users_servers :: server_id :: NAME => Ok (Field :: server_id) , crate :: prisma :: users_servers :: display_name :: NAME => Ok (Field :: display_name) , crate :: prisma :: users_servers :: role :: NAME => Ok (Field :: role) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut user_id = None ; let mut server_id = None ; let mut display_name = None ; let mut role = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_servers :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_servers :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: server_id => { if server_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_servers :: server_id :: NAME)) ; } server_id = Some (map . next_value () ?) ; } Field :: display_name => { if display_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_servers :: display_name :: NAME)) ; } display_name = Some (map . next_value () ?) ; } Field :: role => { if role . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_servers :: role :: NAME)) ; } role = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_servers :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_servers :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_servers :: id :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_servers :: user_id :: NAME)) ? ; let server_id = server_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_servers :: server_id :: NAME)) ? ; let display_name = display_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_servers :: display_name :: NAME)) ? ; let role = role . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_servers :: role :: NAME)) ? ; Ok (Data { id , user_id , server_id , display_name , role , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "user_id" , "server_id" , "display_name" , "role" , "user_server_tags" , "servers" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users_servers :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user_server_tags :: Data > } ; (@ field_type ; user_server_tags) => { Vec < crate :: prisma :: user_server_tags :: Data > } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UsersServers" , available relations are "user_server_tags, servers, users")) } ; (@ field_module ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_server_tags :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_servers :: IncludeParam > :: into (crate :: prisma :: users_servers :: user_server_tags :: Include :: $ selection_mode (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_servers :: IncludeParam > :: into (crate :: prisma :: users_servers :: user_server_tags :: Include :: Fetch (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_servers :: IncludeParam > :: into (crate :: prisma :: users_servers :: servers :: Include :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_servers :: IncludeParam > :: into (crate :: prisma :: users_servers :: servers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_servers :: IncludeParam > :: into (crate :: prisma :: users_servers :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_servers :: IncludeParam > :: into (crate :: prisma :: users_servers :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users_servers :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; display_name) => { "display_name" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; user_server_tags) => { "user_server_tags" } ; (@ field_serde_name ; servers) => { "servers" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_users_servers as include;
    pub enum IncludeParam {
        Id(id::Include),
        UserId(user_id::Include),
        ServerId(server_id::Include),
        DisplayName(display_name::Include),
        Role(role::Include),
        UserServerTags(user_server_tags::Include),
        Servers(servers::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::DisplayName(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::UserServerTags(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_users_servers { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: users_servers struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "user_id")] user_id : i32 , # [serde (rename = "server_id")] server_id : i32 , # [serde (rename = "display_name")] display_name : String , # [serde (rename = "role")] role : crate :: prisma :: ServerRole } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_users_servers as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "server_id")]
        pub server_id: i32,
        #[serde(rename = "display_name")]
        pub display_name: String,
        #[serde(rename = "role")]
        pub role: super::ServerRole,
        #[serde(rename = "user_server_tags")]
        pub user_server_tags: Option<Vec<super::user_server_tags::Data>>,
        #[serde(rename = "servers")]
        pub servers: Option<Box<super::servers::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn user_server_tags(
            &self,
        ) -> Result<
            &Vec<super::user_server_tags::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.user_server_tags.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(user_server_tags)),
            )
        }
        pub fn servers(
            &self,
        ) -> Result<&super::servers::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(servers),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        UserServerTags(super::user_server_tags::ManyArgs),
        Servers(super::servers::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserServerTags(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        user_server_tags::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Servers(args) => {
                    let mut selections = < super :: servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(servers::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        SetServerId(i32),
        IncrementServerId(i32),
        DecrementServerId(i32),
        MultiplyServerId(i32),
        DivideServerId(i32),
        SetDisplayName(String),
        SetRole(super::ServerRole),
        ConnectUserServerTags(Vec<super::user_server_tags::UniqueWhereParam>),
        DisconnectUserServerTags(Vec<super::user_server_tags::UniqueWhereParam>),
        SetUserServerTags(Vec<super::user_server_tags::UniqueWhereParam>),
        ConnectServers(super::servers::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetDisplayName(value) => (
                    display_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetRole(value) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::ConnectUserServerTags(where_params) => (
                    user_server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUserServerTags(where_params) => (
                    user_server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUserServerTags(where_params) => (
                    user_server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectServers(where_param) => (
                    servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        UserId(i32),
        ServerId(i32),
        DisplayName(String),
        Role(super::ServerRole),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::ServerId(value) => Self::SetServerId(value),
                UncheckedSetParam::DisplayName(value) => Self::SetDisplayName(value),
                UncheckedSetParam::Role(value) => Self::SetRole(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        ServerId(::prisma_client_rust::Direction),
        DisplayName(::prisma_client_rust::Direction),
        Role(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ServerId(direction) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DisplayName(direction) => (
                    display_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Role(direction) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        UserId(_prisma::read_filters::IntFilter),
        ServerId(_prisma::read_filters::IntFilter),
        DisplayName(_prisma::read_filters::StringFilter),
        Role(_prisma::read_filters::server_roleFilter),
        UserServerTagsSome(Vec<super::user_server_tags::WhereParam>),
        UserServerTagsEvery(Vec<super::user_server_tags::WhereParam>),
        UserServerTagsNone(Vec<super::user_server_tags::WhereParam>),
        ServersIs(Vec<super::servers::WhereParam>),
        ServersIsNot(Vec<super::servers::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::ServerId(value) => (server_id::NAME, value.into()),
                Self::DisplayName(value) => (display_name::NAME, value.into()),
                Self::Role(value) => (role::NAME, value.into()),
                Self::UserServerTagsSome(where_params) => (
                    user_server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserServerTagsEvery(where_params) => (
                    user_server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserServerTagsNone(where_params) => (
                    user_server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIs(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIsNot(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(server_id::NAME),
                ::prisma_client_rust::sel(display_name::NAME),
                ::prisma_client_rust::sel(role::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            display_name: String,
            role: super::ServerRole,
            servers: super::servers::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                display_name::set(display_name),
                role::set(role),
                servers::connect(servers),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_id: i32,
            server_id: i32,
            display_name: String,
            role: super::ServerRole,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_id::set(user_id),
                server_id::set(server_id),
                display_name::set(display_name),
                role::set(role),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, String, super::ServerRole, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, server_id, display_name, role, mut _params)| {
                    _params.extend([
                        user_id::set(user_id),
                        server_id::set(server_id),
                        display_name::set(display_name),
                        role::set(role),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (display_name, role, servers, users, mut _params): (
                String,
                super::ServerRole,
                super::servers::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                display_name::set(display_name),
                role::set(role),
                servers::connect(servers),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod servers {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "servers";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod text_channel_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text_channel_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTextChannelId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TextChannelId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TextChannelId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TextChannelId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            TextChannelId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTextChannelId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTextChannelId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTextChannelId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTextChannelId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TextChannelId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TextChannelId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "description";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDescription(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Description(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Description,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Description(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Description(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod channel_groups {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "channel_groups";
        pub struct Fetch(pub channel_groups::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<channel_groups::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: channel_groups::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: channel_groups::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ChannelGroups(v)
            }
        }
        pub fn fetch(params: Vec<channel_groups::WhereParam>) -> Fetch {
            Fetch(channel_groups::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<channel_groups::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChannelGroups(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<channel_groups::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<channel_groups::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectChannelGroups(params)
        }
        pub fn set(params: Vec<channel_groups::UniqueWhereParam>) -> SetParam {
            SetParam::SetChannelGroups(params)
        }
        pub fn some(value: Vec<channel_groups::WhereParam>) -> WhereParam {
            WhereParam::ChannelGroupsSome(value)
        }
        pub fn every(value: Vec<channel_groups::WhereParam>) -> WhereParam {
            WhereParam::ChannelGroupsEvery(value)
        }
        pub fn none(value: Vec<channel_groups::WhereParam>) -> WhereParam {
            WhereParam::ChannelGroupsNone(value)
        }
        pub enum Include {
            Select(channel_groups::ManyArgs, Vec<channel_groups::SelectParam>),
            Include(channel_groups::ManyArgs, Vec<channel_groups::IncludeParam>),
            Fetch(channel_groups::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelGroups(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: channel_groups::ManyArgs,
                nested_selections: Vec<channel_groups::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: channel_groups::ManyArgs,
                nested_selections: Vec<channel_groups::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(channel_groups::ManyArgs, Vec<channel_groups::SelectParam>),
            Include(channel_groups::ManyArgs, Vec<channel_groups::IncludeParam>),
            Fetch(channel_groups::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelGroups(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: channel_groups::ManyArgs,
                nested_selections: Vec<channel_groups::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: channel_groups::ManyArgs,
                nested_selections: Vec<channel_groups::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod server_tags {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_tags";
        pub struct Fetch(pub server_tags::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<server_tags::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: server_tags::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: server_tags::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ServerTags(v)
            }
        }
        pub fn fetch(params: Vec<server_tags::WhereParam>) -> Fetch {
            Fetch(server_tags::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<server_tags::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectServerTags(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<server_tags::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<server_tags::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectServerTags(params)
        }
        pub fn set(params: Vec<server_tags::UniqueWhereParam>) -> SetParam {
            SetParam::SetServerTags(params)
        }
        pub fn some(value: Vec<server_tags::WhereParam>) -> WhereParam {
            WhereParam::ServerTagsSome(value)
        }
        pub fn every(value: Vec<server_tags::WhereParam>) -> WhereParam {
            WhereParam::ServerTagsEvery(value)
        }
        pub fn none(value: Vec<server_tags::WhereParam>) -> WhereParam {
            WhereParam::ServerTagsNone(value)
        }
        pub enum Include {
            Select(server_tags::ManyArgs, Vec<server_tags::SelectParam>),
            Include(server_tags::ManyArgs, Vec<server_tags::IncludeParam>),
            Fetch(server_tags::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerTags(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <server_tags::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: server_tags::ManyArgs,
                nested_selections: Vec<server_tags::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: server_tags::ManyArgs,
                nested_selections: Vec<server_tags::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(server_tags::ManyArgs, Vec<server_tags::SelectParam>),
            Include(server_tags::ManyArgs, Vec<server_tags::IncludeParam>),
            Fetch(server_tags::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerTags(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <server_tags::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: server_tags::ManyArgs,
                nested_selections: Vec<server_tags::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: server_tags::ManyArgs,
                nested_selections: Vec<server_tags::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod text_channels {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text_channels";
        pub struct Fetch(pub text_channels::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<text_channels::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: text_channels::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: text_channels::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::TextChannels(v)
            }
        }
        pub fn fetch(params: Vec<text_channels::WhereParam>) -> Fetch {
            Fetch(text_channels::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<text_channels::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTextChannels(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<text_channels::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<text_channels::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTextChannels(params)
        }
        pub fn set(params: Vec<text_channels::UniqueWhereParam>) -> SetParam {
            SetParam::SetTextChannels(params)
        }
        pub fn some(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsSome(value)
        }
        pub fn every(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsEvery(value)
        }
        pub fn none(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsNone(value)
        }
        pub enum Include {
            Select(text_channels::ManyArgs, Vec<text_channels::SelectParam>),
            Include(text_channels::ManyArgs, Vec<text_channels::IncludeParam>),
            Fetch(text_channels::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TextChannels(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(text_channels::ManyArgs, Vec<text_channels::SelectParam>),
            Include(text_channels::ManyArgs, Vec<text_channels::IncludeParam>),
            Fetch(text_channels::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TextChannels(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod users_servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_servers";
        pub struct Fetch(pub users_servers::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users_servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: users_servers::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: users_servers::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersServers(v)
            }
        }
        pub fn fetch(params: Vec<users_servers::WhereParam>) -> Fetch {
            Fetch(users_servers::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<users_servers::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<users_servers::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<users_servers::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUsersServers(params)
        }
        pub fn set(params: Vec<users_servers::UniqueWhereParam>) -> SetParam {
            SetParam::SetUsersServers(params)
        }
        pub fn some(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersSome(value)
        }
        pub fn every(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersEvery(value)
        }
        pub fn none(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersNone(value)
        }
        pub enum Include {
            Select(users_servers::ManyArgs, Vec<users_servers::SelectParam>),
            Include(users_servers::ManyArgs, Vec<users_servers::IncludeParam>),
            Fetch(users_servers::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersServers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(users_servers::ManyArgs, Vec<users_servers::SelectParam>),
            Include(users_servers::ManyArgs, Vec<users_servers::IncludeParam>),
            Fetch(users_servers::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersServers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_servers::ManyArgs,
                nested_selections: Vec<users_servers::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod voice_channel {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "voice_channel";
        pub struct Fetch(pub voice_channel::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<voice_channel::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: voice_channel::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: voice_channel::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::VoiceChannel(v)
            }
        }
        pub fn fetch(params: Vec<voice_channel::WhereParam>) -> Fetch {
            Fetch(voice_channel::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<voice_channel::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectVoiceChannel(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<voice_channel::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<voice_channel::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectVoiceChannel(params)
        }
        pub fn set(params: Vec<voice_channel::UniqueWhereParam>) -> SetParam {
            SetParam::SetVoiceChannel(params)
        }
        pub fn some(value: Vec<voice_channel::WhereParam>) -> WhereParam {
            WhereParam::VoiceChannelSome(value)
        }
        pub fn every(value: Vec<voice_channel::WhereParam>) -> WhereParam {
            WhereParam::VoiceChannelEvery(value)
        }
        pub fn none(value: Vec<voice_channel::WhereParam>) -> WhereParam {
            WhereParam::VoiceChannelNone(value)
        }
        pub enum Include {
            Select(voice_channel::ManyArgs, Vec<voice_channel::SelectParam>),
            Include(voice_channel::ManyArgs, Vec<voice_channel::IncludeParam>),
            Fetch(voice_channel::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VoiceChannel(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(voice_channel::ManyArgs, Vec<voice_channel::SelectParam>),
            Include(voice_channel::ManyArgs, Vec<voice_channel::IncludeParam>),
            Fetch(voice_channel::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VoiceChannel(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        name: String,
        text_channel_id: i32,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, i32, String, Vec<SetParam>) {
        (name, text_channel_id, description, _params)
    }
    pub fn create_unchecked(
        name: String,
        text_channel_id: i32,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, i32, String, Vec<SetParam>) {
        (name, text_channel_id, description, _params)
    }
    #[macro_export]
    macro_rules ! _select_servers { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: servers :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: servers :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: servers :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: servers :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , text_channel_id , description , channel_groups , server_tags , text_channels , users_servers , voice_channel } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: servers :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: servers :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: servers :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: servers :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: servers :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: servers :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "text_channel_id" , "description" , "channel_groups" , "server_tags" , "text_channels" , "users_servers" , "voice_channel"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: servers :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; text_channel_id) => { i32 } ; (@ field_type ; description) => { String } ; (@ field_type ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < channel_groups :: Data > } ; (@ field_type ; channel_groups) => { Vec < crate :: prisma :: channel_groups :: Data > } ; (@ field_type ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < server_tags :: Data > } ; (@ field_type ; server_tags) => { Vec < crate :: prisma :: server_tags :: Data > } ; (@ field_type ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channels :: Data > } ; (@ field_type ; text_channels) => { Vec < crate :: prisma :: text_channels :: Data > } ; (@ field_type ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_servers :: Data > } ; (@ field_type ; users_servers) => { Vec < crate :: prisma :: users_servers :: Data > } ; (@ field_type ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < voice_channel :: Data > } ; (@ field_type ; voice_channel) => { Vec < crate :: prisma :: voice_channel :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Servers" , available relations are "id, name, text_channel_id, description, channel_groups, server_tags, text_channels, users_servers, voice_channel")) } ; (@ field_module ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: channel_groups :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: server_tags :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channels :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: voice_channel :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: name :: Select) } ; (@ selection_field_to_selection_param ; text_channel_id) => { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: text_channel_id :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: description :: Select) } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: channel_groups :: Select :: $ selection_mode (crate :: prisma :: channel_groups :: ManyArgs :: new (crate :: prisma :: channel_groups :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: channel_groups :: Select :: Fetch (crate :: prisma :: channel_groups :: ManyArgs :: new (crate :: prisma :: channel_groups :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: server_tags :: Select :: $ selection_mode (crate :: prisma :: server_tags :: ManyArgs :: new (crate :: prisma :: server_tags :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: server_tags :: Select :: Fetch (crate :: prisma :: server_tags :: ManyArgs :: new (crate :: prisma :: server_tags :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: text_channels :: Select :: $ selection_mode (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: text_channels :: Select :: Fetch (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: users_servers :: Select :: $ selection_mode (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: users_servers :: Select :: Fetch (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: voice_channel :: Select :: $ selection_mode (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: voice_channel :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: SelectParam > :: into (crate :: prisma :: servers :: voice_channel :: Select :: Fetch (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: servers :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; text_channel_id) => { "text_channel_id" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; channel_groups) => { "channel_groups" } ; (@ field_serde_name ; server_tags) => { "server_tags" } ; (@ field_serde_name ; text_channels) => { "text_channels" } ; (@ field_serde_name ; users_servers) => { "users_servers" } ; (@ field_serde_name ; voice_channel) => { "voice_channel" } ; }
    pub use _select_servers as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        TextChannelId(text_channel_id::Select),
        Description(description::Select),
        ChannelGroups(channel_groups::Select),
        ServerTags(server_tags::Select),
        TextChannels(text_channels::Select),
        UsersServers(users_servers::Select),
        VoiceChannel(voice_channel::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::TextChannelId(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::ChannelGroups(data) => data.to_selection(),
                Self::ServerTags(data) => data.to_selection(),
                Self::TextChannels(data) => data.to_selection(),
                Self::UsersServers(data) => data.to_selection(),
                Self::VoiceChannel(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_servers { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: servers :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: servers :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: servers :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: servers :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: servers :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { channel_groups , server_tags , text_channels , users_servers , voice_channel } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub name : String , pub text_channel_id : i32 , pub description : String , $ (pub $ field : crate :: prisma :: servers :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (text_channel_id) , stringify ! (description)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: servers :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: servers :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: servers :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: servers :: text_channel_id :: NAME , & self . text_channel_id) ? ; state . serialize_field (crate :: prisma :: servers :: description :: NAME , & self . description) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , text_channel_id , description } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: servers :: $ field :: NAME) , + , crate :: prisma :: servers :: id :: NAME , crate :: prisma :: servers :: name :: NAME , crate :: prisma :: servers :: text_channel_id :: NAME , crate :: prisma :: servers :: description :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: servers :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: servers :: id :: NAME => Ok (Field :: id) , crate :: prisma :: servers :: name :: NAME => Ok (Field :: name) , crate :: prisma :: servers :: text_channel_id :: NAME => Ok (Field :: text_channel_id) , crate :: prisma :: servers :: description :: NAME => Ok (Field :: description) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut text_channel_id = None ; let mut description = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: servers :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: servers :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: text_channel_id => { if text_channel_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: servers :: text_channel_id :: NAME)) ; } text_channel_id = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: servers :: description :: NAME)) ; } description = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: servers :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: servers :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: servers :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: servers :: name :: NAME)) ? ; let text_channel_id = text_channel_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: servers :: text_channel_id :: NAME)) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: servers :: description :: NAME)) ? ; Ok (Data { id , name , text_channel_id , description , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "text_channel_id" , "description" , "channel_groups" , "server_tags" , "text_channels" , "users_servers" , "voice_channel"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: servers :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < channel_groups :: Data > } ; (@ field_type ; channel_groups) => { Vec < crate :: prisma :: channel_groups :: Data > } ; (@ field_type ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < server_tags :: Data > } ; (@ field_type ; server_tags) => { Vec < crate :: prisma :: server_tags :: Data > } ; (@ field_type ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channels :: Data > } ; (@ field_type ; text_channels) => { Vec < crate :: prisma :: text_channels :: Data > } ; (@ field_type ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_servers :: Data > } ; (@ field_type ; users_servers) => { Vec < crate :: prisma :: users_servers :: Data > } ; (@ field_type ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < voice_channel :: Data > } ; (@ field_type ; voice_channel) => { Vec < crate :: prisma :: voice_channel :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Servers" , available relations are "channel_groups, server_tags, text_channels, users_servers, voice_channel")) } ; (@ field_module ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: channel_groups :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: server_tags :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channels :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: voice_channel :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: channel_groups :: Include :: $ selection_mode (crate :: prisma :: channel_groups :: ManyArgs :: new (crate :: prisma :: channel_groups :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: channel_groups :: Include :: Fetch (crate :: prisma :: channel_groups :: ManyArgs :: new (crate :: prisma :: channel_groups :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: server_tags :: Include :: $ selection_mode (crate :: prisma :: server_tags :: ManyArgs :: new (crate :: prisma :: server_tags :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: server_tags :: Include :: Fetch (crate :: prisma :: server_tags :: ManyArgs :: new (crate :: prisma :: server_tags :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: text_channels :: Include :: $ selection_mode (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: text_channels :: Include :: Fetch (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: users_servers :: Include :: $ selection_mode (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: users_servers :: Include :: Fetch (crate :: prisma :: users_servers :: ManyArgs :: new (crate :: prisma :: users_servers :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: voice_channel :: Include :: $ selection_mode (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: voice_channel :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: servers :: IncludeParam > :: into (crate :: prisma :: servers :: voice_channel :: Include :: Fetch (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: servers :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; text_channel_id) => { "text_channel_id" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; channel_groups) => { "channel_groups" } ; (@ field_serde_name ; server_tags) => { "server_tags" } ; (@ field_serde_name ; text_channels) => { "text_channels" } ; (@ field_serde_name ; users_servers) => { "users_servers" } ; (@ field_serde_name ; voice_channel) => { "voice_channel" } ; }
    pub use _include_servers as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        TextChannelId(text_channel_id::Include),
        Description(description::Include),
        ChannelGroups(channel_groups::Include),
        ServerTags(server_tags::Include),
        TextChannels(text_channels::Include),
        UsersServers(users_servers::Include),
        VoiceChannel(voice_channel::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::TextChannelId(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::ChannelGroups(data) => data.to_selection(),
                Self::ServerTags(data) => data.to_selection(),
                Self::TextChannels(data) => data.to_selection(),
                Self::UsersServers(data) => data.to_selection(),
                Self::VoiceChannel(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_servers { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: servers struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "name")] name : String , # [serde (rename = "text_channel_id")] text_channel_id : i32 , # [serde (rename = "description")] description : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_servers as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "text_channel_id")]
        pub text_channel_id: i32,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "channel_groups")]
        pub channel_groups: Option<Vec<super::channel_groups::Data>>,
        #[serde(rename = "server_tags")]
        pub server_tags: Option<Vec<super::server_tags::Data>>,
        #[serde(rename = "text_channels")]
        pub text_channels: Option<Vec<super::text_channels::Data>>,
        #[serde(rename = "users_servers")]
        pub users_servers: Option<Vec<super::users_servers::Data>>,
        #[serde(rename = "voice_channel")]
        pub voice_channel: Option<Vec<super::voice_channel::Data>>,
    }
    impl Data {
        pub fn channel_groups(
            &self,
        ) -> Result<&Vec<super::channel_groups::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.channel_groups
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(channel_groups),
                ))
        }
        pub fn server_tags(
            &self,
        ) -> Result<&Vec<super::server_tags::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.server_tags
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(server_tags),
                ))
        }
        pub fn text_channels(
            &self,
        ) -> Result<&Vec<super::text_channels::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.text_channels
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(text_channels),
                ))
        }
        pub fn users_servers(
            &self,
        ) -> Result<&Vec<super::users_servers::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.users_servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users_servers),
                ))
        }
        pub fn voice_channel(
            &self,
        ) -> Result<&Vec<super::voice_channel::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.voice_channel
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(voice_channel),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        ChannelGroups(super::channel_groups::ManyArgs),
        ServerTags(super::server_tags::ManyArgs),
        TextChannels(super::text_channels::ManyArgs),
        UsersServers(super::users_servers::ManyArgs),
        VoiceChannel(super::voice_channel::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ChannelGroups(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        channel_groups::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::ServerTags(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        server_tags::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::TextChannels(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        text_channels::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::UsersServers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        users_servers::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::VoiceChannel(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        voice_channel::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetName(String),
        SetTextChannelId(i32),
        IncrementTextChannelId(i32),
        DecrementTextChannelId(i32),
        MultiplyTextChannelId(i32),
        DivideTextChannelId(i32),
        SetDescription(String),
        ConnectChannelGroups(Vec<super::channel_groups::UniqueWhereParam>),
        DisconnectChannelGroups(Vec<super::channel_groups::UniqueWhereParam>),
        SetChannelGroups(Vec<super::channel_groups::UniqueWhereParam>),
        ConnectServerTags(Vec<super::server_tags::UniqueWhereParam>),
        DisconnectServerTags(Vec<super::server_tags::UniqueWhereParam>),
        SetServerTags(Vec<super::server_tags::UniqueWhereParam>),
        ConnectTextChannels(Vec<super::text_channels::UniqueWhereParam>),
        DisconnectTextChannels(Vec<super::text_channels::UniqueWhereParam>),
        SetTextChannels(Vec<super::text_channels::UniqueWhereParam>),
        ConnectUsersServers(Vec<super::users_servers::UniqueWhereParam>),
        DisconnectUsersServers(Vec<super::users_servers::UniqueWhereParam>),
        SetUsersServers(Vec<super::users_servers::UniqueWhereParam>),
        ConnectVoiceChannel(Vec<super::voice_channel::UniqueWhereParam>),
        DisconnectVoiceChannel(Vec<super::voice_channel::UniqueWhereParam>),
        SetVoiceChannel(Vec<super::voice_channel::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetDescription(value) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectChannelGroups(where_params) => (
                    channel_groups::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::channel_groups::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectChannelGroups(where_params) => (
                    channel_groups::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::channel_groups::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetChannelGroups(where_params) => (
                    channel_groups::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::channel_groups::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectServerTags(where_params) => (
                    server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectServerTags(where_params) => (
                    server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetServerTags(where_params) => (
                    server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectTextChannels(where_params) => (
                    text_channels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channels::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectTextChannels(where_params) => (
                    text_channels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channels::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTextChannels(where_params) => (
                    text_channels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channels::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsersServers(where_params) => (
                    users_servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUsersServers(where_params) => (
                    users_servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUsersServers(where_params) => (
                    users_servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectVoiceChannel(where_params) => (
                    voice_channel::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::voice_channel::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectVoiceChannel(where_params) => (
                    voice_channel::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::voice_channel::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetVoiceChannel(where_params) => (
                    voice_channel::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::voice_channel::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Name(String),
        TextChannelId(i32),
        Description(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::TextChannelId(value) => Self::SetTextChannelId(value),
                UncheckedSetParam::Description(value) => Self::SetDescription(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        TextChannelId(::prisma_client_rust::Direction),
        Description(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TextChannelId(direction) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Description(direction) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        TextChannelId(_prisma::read_filters::IntFilter),
        Description(_prisma::read_filters::StringFilter),
        ChannelGroupsSome(Vec<super::channel_groups::WhereParam>),
        ChannelGroupsEvery(Vec<super::channel_groups::WhereParam>),
        ChannelGroupsNone(Vec<super::channel_groups::WhereParam>),
        ServerTagsSome(Vec<super::server_tags::WhereParam>),
        ServerTagsEvery(Vec<super::server_tags::WhereParam>),
        ServerTagsNone(Vec<super::server_tags::WhereParam>),
        TextChannelsSome(Vec<super::text_channels::WhereParam>),
        TextChannelsEvery(Vec<super::text_channels::WhereParam>),
        TextChannelsNone(Vec<super::text_channels::WhereParam>),
        UsersServersSome(Vec<super::users_servers::WhereParam>),
        UsersServersEvery(Vec<super::users_servers::WhereParam>),
        UsersServersNone(Vec<super::users_servers::WhereParam>),
        VoiceChannelSome(Vec<super::voice_channel::WhereParam>),
        VoiceChannelEvery(Vec<super::voice_channel::WhereParam>),
        VoiceChannelNone(Vec<super::voice_channel::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::TextChannelId(value) => (text_channel_id::NAME, value.into()),
                Self::Description(value) => (description::NAME, value.into()),
                Self::ChannelGroupsSome(where_params) => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelGroupsEvery(where_params) => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelGroupsNone(where_params) => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServerTagsSome(where_params) => (
                    server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServerTagsEvery(where_params) => (
                    server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServerTagsNone(where_params) => (
                    server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelsSome(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelsEvery(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelsNone(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersSome(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersEvery(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersNone(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VoiceChannelSome(where_params) => (
                    voice_channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VoiceChannelEvery(where_params) => (
                    voice_channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VoiceChannelNone(where_params) => (
                    voice_channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(text_channel_id::NAME),
                ::prisma_client_rust::sel(description::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            text_channel_id: i32,
            description: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                text_channel_id::set(text_channel_id),
                description::set(description),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            text_channel_id: i32,
            description: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                text_channel_id::set(text_channel_id),
                description::set(description),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, i32, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, text_channel_id, description, mut _params)| {
                    _params.extend([
                        name::set(name),
                        text_channel_id::set(text_channel_id),
                        description::set(description),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, text_channel_id, description, mut _params): (String, i32, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                name::set(name),
                text_channel_id::set(text_channel_id),
                description::set(description),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod server_tags {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "server_tags";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod server_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetServerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ServerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ServerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ServerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ServerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementServerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementServerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyServerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideServerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod order {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "order";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOrder(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Order(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Order(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Order(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Order, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementOrder(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementOrder(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyOrder(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideOrder(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Order(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Order(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod color {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "Color";
        pub struct Set(pub self::Colors);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetColor(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Color(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::Colors) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Color(direction)
        }
        pub fn equals(value: self::Colors) -> WhereParam {
            WhereParam::Color(_prisma::read_filters::colorsFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::colorsFilter,
            Color,
            {
                fn in_vec(_: Vec<super::super::Colors>) -> InVec;
                fn not_in_vec(_: Vec<super::super::Colors>) -> NotInVec;
                fn not(_: super::super::Colors) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Color(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Color(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "servers";
        pub struct Fetch(pub servers::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Servers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(servers::UniqueArgs::new())
        }
        pub struct Connect(servers::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: servers::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIs(value)
        }
        pub fn is_not(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIsNot(value)
        }
        pub enum Include {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Servers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Servers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod user_server_tags {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_server_tags";
        pub struct Fetch(pub user_server_tags::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<user_server_tags::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: user_server_tags::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: user_server_tags::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UserServerTags(v)
            }
        }
        pub fn fetch(params: Vec<user_server_tags::WhereParam>) -> Fetch {
            Fetch(user_server_tags::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<user_server_tags::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUserServerTags(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<user_server_tags::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<user_server_tags::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUserServerTags(params)
        }
        pub fn set(params: Vec<user_server_tags::UniqueWhereParam>) -> SetParam {
            SetParam::SetUserServerTags(params)
        }
        pub fn some(value: Vec<user_server_tags::WhereParam>) -> WhereParam {
            WhereParam::UserServerTagsSome(value)
        }
        pub fn every(value: Vec<user_server_tags::WhereParam>) -> WhereParam {
            WhereParam::UserServerTagsEvery(value)
        }
        pub fn none(value: Vec<user_server_tags::WhereParam>) -> WhereParam {
            WhereParam::UserServerTagsNone(value)
        }
        pub enum Include {
            Select(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::SelectParam>,
            ),
            Include(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::IncludeParam>,
            ),
            Fetch(user_server_tags::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserServerTags(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::SelectParam>,
            ),
            Include(
                user_server_tags::ManyArgs,
                Vec<user_server_tags::IncludeParam>,
            ),
            Fetch(user_server_tags::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserServerTags(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: user_server_tags::ManyArgs,
                nested_selections: Vec<user_server_tags::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        order: i32,
        name: String,
        color: super::Colors,
        servers: super::servers::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        String,
        super::Colors,
        super::servers::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (order, name, color, servers, _params)
    }
    pub fn create_unchecked(
        server_id: i32,
        order: i32,
        name: String,
        color: super::Colors,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, super::Colors, Vec<SetParam>) {
        (server_id, order, name, color, _params)
    }
    #[macro_export]
    macro_rules ! _select_server_tags { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: server_tags :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: server_tags :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: server_tags :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: server_tags :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , server_id , order , name , color , servers , user_server_tags } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: server_tags :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: server_tags :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: server_tags :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: server_tags :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: server_tags :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: server_tags :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "order" , "name" , "Color" , "servers" , "user_server_tags"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: server_tags :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; server_id) => { i32 } ; (@ field_type ; order) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; color) => { crate :: prisma :: Colors } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user_server_tags :: Data > } ; (@ field_type ; user_server_tags) => { Vec < crate :: prisma :: user_server_tags :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ServerTags" , available relations are "id, server_id, order, name, color, servers, user_server_tags")) } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_server_tags :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: id :: Select) } ; (@ selection_field_to_selection_param ; server_id) => { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: server_id :: Select) } ; (@ selection_field_to_selection_param ; order) => { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: order :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: name :: Select) } ; (@ selection_field_to_selection_param ; color) => { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: color :: Select) } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: servers :: Select :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: servers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: user_server_tags :: Select :: $ selection_mode (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: server_tags :: SelectParam > :: into (crate :: prisma :: server_tags :: user_server_tags :: Select :: Fetch (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: server_tags :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; color) => { "Color" } ; (@ field_serde_name ; servers) => { "servers" } ; (@ field_serde_name ; user_server_tags) => { "user_server_tags" } ; }
    pub use _select_server_tags as select;
    pub enum SelectParam {
        Id(id::Select),
        ServerId(server_id::Select),
        Order(order::Select),
        Name(name::Select),
        Color(color::Select),
        Servers(servers::Select),
        UserServerTags(user_server_tags::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Color(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
                Self::UserServerTags(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_server_tags { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: server_tags :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: server_tags :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: server_tags :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: server_tags :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { servers , user_server_tags } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub server_id : i32 , pub order : i32 , pub name : String , pub color : crate :: prisma :: Colors , $ (pub $ field : crate :: prisma :: server_tags :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (server_id) , stringify ! (order) , stringify ! (name) , stringify ! (color)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: server_tags :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: server_tags :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: server_tags :: server_id :: NAME , & self . server_id) ? ; state . serialize_field (crate :: prisma :: server_tags :: order :: NAME , & self . order) ? ; state . serialize_field (crate :: prisma :: server_tags :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: server_tags :: color :: NAME , & self . color) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , server_id , order , name , color } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: server_tags :: $ field :: NAME) , + , crate :: prisma :: server_tags :: id :: NAME , crate :: prisma :: server_tags :: server_id :: NAME , crate :: prisma :: server_tags :: order :: NAME , crate :: prisma :: server_tags :: name :: NAME , crate :: prisma :: server_tags :: color :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: server_tags :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: server_tags :: id :: NAME => Ok (Field :: id) , crate :: prisma :: server_tags :: server_id :: NAME => Ok (Field :: server_id) , crate :: prisma :: server_tags :: order :: NAME => Ok (Field :: order) , crate :: prisma :: server_tags :: name :: NAME => Ok (Field :: name) , crate :: prisma :: server_tags :: color :: NAME => Ok (Field :: color) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut server_id = None ; let mut order = None ; let mut name = None ; let mut color = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: server_tags :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: server_id => { if server_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: server_tags :: server_id :: NAME)) ; } server_id = Some (map . next_value () ?) ; } Field :: order => { if order . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: server_tags :: order :: NAME)) ; } order = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: server_tags :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: color => { if color . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: server_tags :: color :: NAME)) ; } color = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: server_tags :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: server_tags :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: server_tags :: id :: NAME)) ? ; let server_id = server_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: server_tags :: server_id :: NAME)) ? ; let order = order . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: server_tags :: order :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: server_tags :: name :: NAME)) ? ; let color = color . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: server_tags :: color :: NAME)) ? ; Ok (Data { id , server_id , order , name , color , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "order" , "name" , "Color" , "servers" , "user_server_tags"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: server_tags :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < user_server_tags :: Data > } ; (@ field_type ; user_server_tags) => { Vec < crate :: prisma :: user_server_tags :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ServerTags" , available relations are "servers, user_server_tags")) } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; user_server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: user_server_tags :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: server_tags :: IncludeParam > :: into (crate :: prisma :: server_tags :: servers :: Include :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: server_tags :: IncludeParam > :: into (crate :: prisma :: server_tags :: servers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: server_tags :: IncludeParam > :: into (crate :: prisma :: server_tags :: user_server_tags :: Include :: $ selection_mode (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: user_server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user_server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: server_tags :: IncludeParam > :: into (crate :: prisma :: server_tags :: user_server_tags :: Include :: Fetch (crate :: prisma :: user_server_tags :: ManyArgs :: new (crate :: prisma :: user_server_tags :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: server_tags :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; color) => { "Color" } ; (@ field_serde_name ; servers) => { "servers" } ; (@ field_serde_name ; user_server_tags) => { "user_server_tags" } ; }
    pub use _include_server_tags as include;
    pub enum IncludeParam {
        Id(id::Include),
        ServerId(server_id::Include),
        Order(order::Include),
        Name(name::Include),
        Color(color::Include),
        Servers(servers::Include),
        UserServerTags(user_server_tags::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Color(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
                Self::UserServerTags(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_server_tags { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: server_tags struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "server_id")] server_id : i32 , # [serde (rename = "order")] order : i32 , # [serde (rename = "name")] name : String , # [serde (rename = "Color")] color : crate :: prisma :: Colors } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_server_tags as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "server_id")]
        pub server_id: i32,
        #[serde(rename = "order")]
        pub order: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "Color")]
        pub color: super::Colors,
        #[serde(rename = "servers")]
        pub servers: Option<Box<super::servers::Data>>,
        #[serde(rename = "user_server_tags")]
        pub user_server_tags: Option<Vec<super::user_server_tags::Data>>,
    }
    impl Data {
        pub fn servers(
            &self,
        ) -> Result<&super::servers::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(servers),
                ))
                .map(|v| v.as_ref())
        }
        pub fn user_server_tags(
            &self,
        ) -> Result<
            &Vec<super::user_server_tags::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.user_server_tags.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(user_server_tags)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Servers(super::servers::UniqueArgs),
        UserServerTags(super::user_server_tags::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Servers(args) => {
                    let mut selections = < super :: servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(servers::NAME, None, [], selections)
                }
                Self::UserServerTags(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        user_server_tags::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetServerId(i32),
        IncrementServerId(i32),
        DecrementServerId(i32),
        MultiplyServerId(i32),
        DivideServerId(i32),
        SetOrder(i32),
        IncrementOrder(i32),
        DecrementOrder(i32),
        MultiplyOrder(i32),
        DivideOrder(i32),
        SetName(String),
        SetColor(super::Colors),
        ConnectServers(super::servers::UniqueWhereParam),
        ConnectUserServerTags(Vec<super::user_server_tags::UniqueWhereParam>),
        DisconnectUserServerTags(Vec<super::user_server_tags::UniqueWhereParam>),
        SetUserServerTags(Vec<super::user_server_tags::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetColor(value) => (
                    color::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::ConnectServers(where_param) => (
                    servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUserServerTags(where_params) => (
                    user_server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUserServerTags(where_params) => (
                    user_server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUserServerTags(where_params) => (
                    user_server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::user_server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        ServerId(i32),
        Order(i32),
        Name(String),
        Color(super::Colors),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::ServerId(value) => Self::SetServerId(value),
                UncheckedSetParam::Order(value) => Self::SetOrder(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Color(value) => Self::SetColor(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ServerId(::prisma_client_rust::Direction),
        Order(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Color(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ServerId(direction) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Order(direction) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Color(direction) => (
                    color::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        ServerId(_prisma::read_filters::IntFilter),
        Order(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        Color(_prisma::read_filters::colorsFilter),
        ServersIs(Vec<super::servers::WhereParam>),
        ServersIsNot(Vec<super::servers::WhereParam>),
        UserServerTagsSome(Vec<super::user_server_tags::WhereParam>),
        UserServerTagsEvery(Vec<super::user_server_tags::WhereParam>),
        UserServerTagsNone(Vec<super::user_server_tags::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::ServerId(value) => (server_id::NAME, value.into()),
                Self::Order(value) => (order::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Color(value) => (color::NAME, value.into()),
                Self::ServersIs(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIsNot(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserServerTagsSome(where_params) => (
                    user_server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserServerTagsEvery(where_params) => (
                    user_server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserServerTagsNone(where_params) => (
                    user_server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(server_id::NAME),
                ::prisma_client_rust::sel(order::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(color::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            order: i32,
            name: String,
            color: super::Colors,
            servers: super::servers::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                color::set(color),
                servers::connect(servers),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            server_id: i32,
            order: i32,
            name: String,
            color: super::Colors,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                server_id::set(server_id),
                order::set(order),
                name::set(name),
                color::set(color),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, String, super::Colors, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(server_id, order, name, color, mut _params)| {
                    _params.extend([
                        server_id::set(server_id),
                        order::set(order),
                        name::set(name),
                        color::set(color),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (order, name, color, servers, mut _params): (
                i32,
                String,
                super::Colors,
                super::servers::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                color::set(color),
                servers::connect(servers),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod user_server_tags {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "user_server_tags";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod server_tag_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_tag_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetServerTagId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ServerTagId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ServerTagId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ServerTagId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ServerTagId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementServerTagId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementServerTagId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyServerTagId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideServerTagId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerTagId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerTagId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_server_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_server_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserServerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserServerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserServerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserServerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            UserServerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserServerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserServerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserServerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserServerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserServerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserServerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod server_tags {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_tags";
        pub struct Fetch(pub server_tags::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<server_tags::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ServerTags(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(server_tags::UniqueArgs::new())
        }
        pub struct Connect(server_tags::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectServerTags(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: server_tags::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<server_tags::WhereParam>) -> WhereParam {
            WhereParam::ServerTagsIs(value)
        }
        pub fn is_not(value: Vec<server_tags::WhereParam>) -> WhereParam {
            WhereParam::ServerTagsIsNot(value)
        }
        pub enum Include {
            Select(Vec<server_tags::SelectParam>),
            Include(Vec<server_tags::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerTags(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <server_tags::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("server_tags", None, [], selections)
            }
            pub fn select(nested_selections: Vec<server_tags::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<server_tags::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<server_tags::SelectParam>),
            Include(Vec<server_tags::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerTags(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <server_tags::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("server_tags", None, [], selections)
            }
            pub fn select(nested_selections: Vec<server_tags::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<server_tags::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users_servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_servers";
        pub struct Fetch(pub users_servers::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users_servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersServers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users_servers::UniqueArgs::new())
        }
        pub struct Connect(users_servers::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users_servers::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersIs(value)
        }
        pub fn is_not(value: Vec<users_servers::WhereParam>) -> WhereParam {
            WhereParam::UsersServersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users_servers::SelectParam>),
            Include(Vec<users_servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersServers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("users_servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users_servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users_servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users_servers::SelectParam>),
            Include(Vec<users_servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersServers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("users_servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users_servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users_servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        server_tags: super::server_tags::UniqueWhereParam,
        users_servers: super::users_servers::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::server_tags::UniqueWhereParam,
        super::users_servers::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (server_tags, users_servers, _params)
    }
    pub fn create_unchecked(
        server_tag_id: i32,
        user_server_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, Vec<SetParam>) {
        (server_tag_id, user_server_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_user_server_tags { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user_server_tags :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user_server_tags :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user_server_tags :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user_server_tags :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , server_tag_id , user_server_id , server_tags , users_servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: user_server_tags :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user_server_tags :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user_server_tags :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user_server_tags :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_server_tags :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_server_tags :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_tag_id" , "user_server_id" , "server_tags" , "users_servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user_server_tags :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; server_tag_id) => { i32 } ; (@ field_type ; user_server_id) => { i32 } ; (@ field_type ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { server_tags :: Data } ; (@ field_type ; server_tags) => { crate :: prisma :: server_tags :: Data } ; (@ field_type ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { users_servers :: Data } ; (@ field_type ; users_servers) => { crate :: prisma :: users_servers :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UserServerTags" , available relations are "id, server_tag_id, user_server_id, server_tags, users_servers")) } ; (@ field_module ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: server_tags :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: user_server_tags :: SelectParam > :: into (crate :: prisma :: user_server_tags :: id :: Select) } ; (@ selection_field_to_selection_param ; server_tag_id) => { Into :: < crate :: prisma :: user_server_tags :: SelectParam > :: into (crate :: prisma :: user_server_tags :: server_tag_id :: Select) } ; (@ selection_field_to_selection_param ; user_server_id) => { Into :: < crate :: prisma :: user_server_tags :: SelectParam > :: into (crate :: prisma :: user_server_tags :: user_server_id :: Select) } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_server_tags :: SelectParam > :: into (crate :: prisma :: user_server_tags :: server_tags :: Select :: $ selection_mode (crate :: prisma :: server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_server_tags :: SelectParam > :: into (crate :: prisma :: user_server_tags :: server_tags :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_server_tags :: SelectParam > :: into (crate :: prisma :: user_server_tags :: users_servers :: Select :: $ selection_mode (crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_server_tags :: SelectParam > :: into (crate :: prisma :: user_server_tags :: users_servers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user_server_tags :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_tag_id) => { "server_tag_id" } ; (@ field_serde_name ; user_server_id) => { "user_server_id" } ; (@ field_serde_name ; server_tags) => { "server_tags" } ; (@ field_serde_name ; users_servers) => { "users_servers" } ; }
    pub use _select_user_server_tags as select;
    pub enum SelectParam {
        Id(id::Select),
        ServerTagId(server_tag_id::Select),
        UserServerId(user_server_id::Select),
        ServerTags(server_tags::Select),
        UsersServers(users_servers::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerTagId(data) => data.to_selection(),
                Self::UserServerId(data) => data.to_selection(),
                Self::ServerTags(data) => data.to_selection(),
                Self::UsersServers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_user_server_tags { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: user_server_tags :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: user_server_tags :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: user_server_tags :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: user_server_tags :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: user_server_tags :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: user_server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { server_tags , users_servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub server_tag_id : i32 , pub user_server_id : i32 , $ (pub $ field : crate :: prisma :: user_server_tags :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (server_tag_id) , stringify ! (user_server_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: user_server_tags :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: user_server_tags :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: user_server_tags :: server_tag_id :: NAME , & self . server_tag_id) ? ; state . serialize_field (crate :: prisma :: user_server_tags :: user_server_id :: NAME , & self . user_server_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , server_tag_id , user_server_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: user_server_tags :: $ field :: NAME) , + , crate :: prisma :: user_server_tags :: id :: NAME , crate :: prisma :: user_server_tags :: server_tag_id :: NAME , crate :: prisma :: user_server_tags :: user_server_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: user_server_tags :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: user_server_tags :: id :: NAME => Ok (Field :: id) , crate :: prisma :: user_server_tags :: server_tag_id :: NAME => Ok (Field :: server_tag_id) , crate :: prisma :: user_server_tags :: user_server_id :: NAME => Ok (Field :: user_server_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut server_tag_id = None ; let mut user_server_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_server_tags :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: server_tag_id => { if server_tag_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_server_tags :: server_tag_id :: NAME)) ; } server_tag_id = Some (map . next_value () ?) ; } Field :: user_server_id => { if user_server_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_server_tags :: user_server_id :: NAME)) ; } user_server_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: user_server_tags :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_server_tags :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_server_tags :: id :: NAME)) ? ; let server_tag_id = server_tag_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_server_tags :: server_tag_id :: NAME)) ? ; let user_server_id = user_server_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: user_server_tags :: user_server_id :: NAME)) ? ; Ok (Data { id , server_tag_id , user_server_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_tag_id" , "user_server_id" , "server_tags" , "users_servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: user_server_tags :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { server_tags :: Data } ; (@ field_type ; server_tags) => { crate :: prisma :: server_tags :: Data } ; (@ field_type ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { users_servers :: Data } ; (@ field_type ; users_servers) => { crate :: prisma :: users_servers :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UserServerTags" , available relations are "server_tags, users_servers")) } ; (@ field_module ; server_tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: server_tags :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_server_tags :: IncludeParam > :: into (crate :: prisma :: user_server_tags :: server_tags :: Include :: $ selection_mode (crate :: prisma :: server_tags :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; server_tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_server_tags :: IncludeParam > :: into (crate :: prisma :: user_server_tags :: server_tags :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: user_server_tags :: IncludeParam > :: into (crate :: prisma :: user_server_tags :: users_servers :: Include :: $ selection_mode (crate :: prisma :: users_servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: user_server_tags :: IncludeParam > :: into (crate :: prisma :: user_server_tags :: users_servers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: user_server_tags :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_tag_id) => { "server_tag_id" } ; (@ field_serde_name ; user_server_id) => { "user_server_id" } ; (@ field_serde_name ; server_tags) => { "server_tags" } ; (@ field_serde_name ; users_servers) => { "users_servers" } ; }
    pub use _include_user_server_tags as include;
    pub enum IncludeParam {
        Id(id::Include),
        ServerTagId(server_tag_id::Include),
        UserServerId(user_server_id::Include),
        ServerTags(server_tags::Include),
        UsersServers(users_servers::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerTagId(data) => data.to_selection(),
                Self::UserServerId(data) => data.to_selection(),
                Self::ServerTags(data) => data.to_selection(),
                Self::UsersServers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_user_server_tags { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: user_server_tags struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "server_tag_id")] server_tag_id : i32 , # [serde (rename = "user_server_id")] user_server_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_user_server_tags as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "server_tag_id")]
        pub server_tag_id: i32,
        #[serde(rename = "user_server_id")]
        pub user_server_id: i32,
        #[serde(rename = "server_tags")]
        pub server_tags: Option<Box<super::server_tags::Data>>,
        #[serde(rename = "users_servers")]
        pub users_servers: Option<Box<super::users_servers::Data>>,
    }
    impl Data {
        pub fn server_tags(
            &self,
        ) -> Result<&super::server_tags::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.server_tags
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(server_tags),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users_servers(
            &self,
        ) -> Result<&super::users_servers::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.users_servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users_servers),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        ServerTags(super::server_tags::UniqueArgs),
        UsersServers(super::users_servers::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ServerTags(args) => {
                    let mut selections = < super :: server_tags :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(server_tags::NAME, None, [], selections)
                }
                Self::UsersServers(args) => {
                    let mut selections = < super :: users_servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users_servers::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetServerTagId(i32),
        IncrementServerTagId(i32),
        DecrementServerTagId(i32),
        MultiplyServerTagId(i32),
        DivideServerTagId(i32),
        SetUserServerId(i32),
        IncrementUserServerId(i32),
        DecrementUserServerId(i32),
        MultiplyUserServerId(i32),
        DivideUserServerId(i32),
        ConnectServerTags(super::server_tags::UniqueWhereParam),
        ConnectUsersServers(super::users_servers::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetServerTagId(value) => (
                    server_tag_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementServerTagId(value) => (
                    server_tag_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementServerTagId(value) => (
                    server_tag_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyServerTagId(value) => (
                    server_tag_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideServerTagId(value) => (
                    server_tag_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserServerId(value) => (
                    user_server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserServerId(value) => (
                    user_server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserServerId(value) => (
                    user_server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserServerId(value) => (
                    user_server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserServerId(value) => (
                    user_server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectServerTags(where_param) => (
                    server_tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::server_tags::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsersServers(where_param) => (
                    users_servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users_servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        ServerTagId(i32),
        UserServerId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::ServerTagId(value) => Self::SetServerTagId(value),
                UncheckedSetParam::UserServerId(value) => Self::SetUserServerId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ServerTagId(::prisma_client_rust::Direction),
        UserServerId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ServerTagId(direction) => (
                    server_tag_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserServerId(direction) => (
                    user_server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        ServerTagId(_prisma::read_filters::IntFilter),
        UserServerId(_prisma::read_filters::IntFilter),
        ServerTagsIs(Vec<super::server_tags::WhereParam>),
        ServerTagsIsNot(Vec<super::server_tags::WhereParam>),
        UsersServersIs(Vec<super::users_servers::WhereParam>),
        UsersServersIsNot(Vec<super::users_servers::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::ServerTagId(value) => (server_tag_id::NAME, value.into()),
                Self::UserServerId(value) => (user_server_id::NAME, value.into()),
                Self::ServerTagsIs(where_params) => (
                    server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServerTagsIsNot(where_params) => (
                    server_tags::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersIs(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersServersIsNot(where_params) => (
                    users_servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(server_tag_id::NAME),
                ::prisma_client_rust::sel(user_server_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            server_tags: super::server_tags::UniqueWhereParam,
            users_servers: super::users_servers::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                server_tags::connect(server_tags),
                users_servers::connect(users_servers),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            server_tag_id: i32,
            user_server_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                server_tag_id::set(server_tag_id),
                user_server_id::set(user_server_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(server_tag_id, user_server_id, mut _params)| {
                    _params.extend([
                        server_tag_id::set(server_tag_id),
                        user_server_id::set(user_server_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (server_tags, users_servers, mut _params): (
                super::server_tags::UniqueWhereParam,
                super::users_servers::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                server_tags::connect(server_tags),
                users_servers::connect(users_servers),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod channel_groups {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "channel_groups";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod server_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetServerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ServerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ServerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ServerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ServerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementServerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementServerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyServerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideServerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod order {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "order";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOrder(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Order(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Order(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Order(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Order, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementOrder(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementOrder(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyOrder(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideOrder(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Order(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Order(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "servers";
        pub struct Fetch(pub servers::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Servers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(servers::UniqueArgs::new())
        }
        pub struct Connect(servers::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: servers::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIs(value)
        }
        pub fn is_not(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIsNot(value)
        }
        pub enum Include {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Servers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Servers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod text_channels {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text_channels";
        pub struct Fetch(pub text_channels::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<text_channels::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: text_channels::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: text_channels::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::TextChannels(v)
            }
        }
        pub fn fetch(params: Vec<text_channels::WhereParam>) -> Fetch {
            Fetch(text_channels::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<text_channels::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTextChannels(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<text_channels::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<text_channels::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTextChannels(params)
        }
        pub fn set(params: Vec<text_channels::UniqueWhereParam>) -> SetParam {
            SetParam::SetTextChannels(params)
        }
        pub fn some(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsSome(value)
        }
        pub fn every(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsEvery(value)
        }
        pub fn none(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsNone(value)
        }
        pub enum Include {
            Select(text_channels::ManyArgs, Vec<text_channels::SelectParam>),
            Include(text_channels::ManyArgs, Vec<text_channels::IncludeParam>),
            Fetch(text_channels::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TextChannels(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(text_channels::ManyArgs, Vec<text_channels::SelectParam>),
            Include(text_channels::ManyArgs, Vec<text_channels::IncludeParam>),
            Fetch(text_channels::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TextChannels(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channels::ManyArgs,
                nested_selections: Vec<text_channels::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod voice_channel {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "voice_channel";
        pub struct Fetch(pub voice_channel::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<voice_channel::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: voice_channel::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: voice_channel::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::VoiceChannel(v)
            }
        }
        pub fn fetch(params: Vec<voice_channel::WhereParam>) -> Fetch {
            Fetch(voice_channel::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<voice_channel::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectVoiceChannel(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<voice_channel::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<voice_channel::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectVoiceChannel(params)
        }
        pub fn set(params: Vec<voice_channel::UniqueWhereParam>) -> SetParam {
            SetParam::SetVoiceChannel(params)
        }
        pub fn some(value: Vec<voice_channel::WhereParam>) -> WhereParam {
            WhereParam::VoiceChannelSome(value)
        }
        pub fn every(value: Vec<voice_channel::WhereParam>) -> WhereParam {
            WhereParam::VoiceChannelEvery(value)
        }
        pub fn none(value: Vec<voice_channel::WhereParam>) -> WhereParam {
            WhereParam::VoiceChannelNone(value)
        }
        pub enum Include {
            Select(voice_channel::ManyArgs, Vec<voice_channel::SelectParam>),
            Include(voice_channel::ManyArgs, Vec<voice_channel::IncludeParam>),
            Fetch(voice_channel::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::VoiceChannel(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(voice_channel::ManyArgs, Vec<voice_channel::SelectParam>),
            Include(voice_channel::ManyArgs, Vec<voice_channel::IncludeParam>),
            Fetch(voice_channel::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::VoiceChannel(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: voice_channel::ManyArgs,
                nested_selections: Vec<voice_channel::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        order: i32,
        name: String,
        servers: super::servers::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (i32, String, super::servers::UniqueWhereParam, Vec<SetParam>) {
        (order, name, servers, _params)
    }
    pub fn create_unchecked(
        server_id: i32,
        order: i32,
        name: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, Vec<SetParam>) {
        (server_id, order, name, _params)
    }
    #[macro_export]
    macro_rules ! _select_channel_groups { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: channel_groups :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: channel_groups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: channel_groups :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: channel_groups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , server_id , order , name , servers , text_channels , voice_channel } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: channel_groups :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: channel_groups :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: channel_groups :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: channel_groups :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: channel_groups :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: channel_groups :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "order" , "name" , "servers" , "text_channels" , "voice_channel"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: channel_groups :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; server_id) => { i32 } ; (@ field_type ; order) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channels :: Data > } ; (@ field_type ; text_channels) => { Vec < crate :: prisma :: text_channels :: Data > } ; (@ field_type ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < voice_channel :: Data > } ; (@ field_type ; voice_channel) => { Vec < crate :: prisma :: voice_channel :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ChannelGroups" , available relations are "id, server_id, order, name, servers, text_channels, voice_channel")) } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channels :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: voice_channel :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: id :: Select) } ; (@ selection_field_to_selection_param ; server_id) => { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: server_id :: Select) } ; (@ selection_field_to_selection_param ; order) => { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: order :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: name :: Select) } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: servers :: Select :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: servers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: text_channels :: Select :: $ selection_mode (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: text_channels :: Select :: Fetch (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: voice_channel :: Select :: $ selection_mode (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: voice_channel :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: channel_groups :: SelectParam > :: into (crate :: prisma :: channel_groups :: voice_channel :: Select :: Fetch (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: channel_groups :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; servers) => { "servers" } ; (@ field_serde_name ; text_channels) => { "text_channels" } ; (@ field_serde_name ; voice_channel) => { "voice_channel" } ; }
    pub use _select_channel_groups as select;
    pub enum SelectParam {
        Id(id::Select),
        ServerId(server_id::Select),
        Order(order::Select),
        Name(name::Select),
        Servers(servers::Select),
        TextChannels(text_channels::Select),
        VoiceChannel(voice_channel::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
                Self::TextChannels(data) => data.to_selection(),
                Self::VoiceChannel(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_channel_groups { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: channel_groups :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: channel_groups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: channel_groups :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: channel_groups :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: channel_groups :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: channel_groups :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { servers , text_channels , voice_channel } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub server_id : i32 , pub order : i32 , pub name : String , $ (pub $ field : crate :: prisma :: channel_groups :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (server_id) , stringify ! (order) , stringify ! (name)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: channel_groups :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: channel_groups :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: channel_groups :: server_id :: NAME , & self . server_id) ? ; state . serialize_field (crate :: prisma :: channel_groups :: order :: NAME , & self . order) ? ; state . serialize_field (crate :: prisma :: channel_groups :: name :: NAME , & self . name) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , server_id , order , name } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: channel_groups :: $ field :: NAME) , + , crate :: prisma :: channel_groups :: id :: NAME , crate :: prisma :: channel_groups :: server_id :: NAME , crate :: prisma :: channel_groups :: order :: NAME , crate :: prisma :: channel_groups :: name :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: channel_groups :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: channel_groups :: id :: NAME => Ok (Field :: id) , crate :: prisma :: channel_groups :: server_id :: NAME => Ok (Field :: server_id) , crate :: prisma :: channel_groups :: order :: NAME => Ok (Field :: order) , crate :: prisma :: channel_groups :: name :: NAME => Ok (Field :: name) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut server_id = None ; let mut order = None ; let mut name = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: channel_groups :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: server_id => { if server_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: channel_groups :: server_id :: NAME)) ; } server_id = Some (map . next_value () ?) ; } Field :: order => { if order . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: channel_groups :: order :: NAME)) ; } order = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: channel_groups :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: channel_groups :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: channel_groups :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: channel_groups :: id :: NAME)) ? ; let server_id = server_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: channel_groups :: server_id :: NAME)) ? ; let order = order . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: channel_groups :: order :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: channel_groups :: name :: NAME)) ? ; Ok (Data { id , server_id , order , name , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "order" , "name" , "servers" , "text_channels" , "voice_channel"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: channel_groups :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channels :: Data > } ; (@ field_type ; text_channels) => { Vec < crate :: prisma :: text_channels :: Data > } ; (@ field_type ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < voice_channel :: Data > } ; (@ field_type ; voice_channel) => { Vec < crate :: prisma :: voice_channel :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ChannelGroups" , available relations are "servers, text_channels, voice_channel")) } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channels :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; voice_channel : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: voice_channel :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: channel_groups :: IncludeParam > :: into (crate :: prisma :: channel_groups :: servers :: Include :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: channel_groups :: IncludeParam > :: into (crate :: prisma :: channel_groups :: servers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: channel_groups :: IncludeParam > :: into (crate :: prisma :: channel_groups :: text_channels :: Include :: $ selection_mode (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: channel_groups :: IncludeParam > :: into (crate :: prisma :: channel_groups :: text_channels :: Include :: Fetch (crate :: prisma :: text_channels :: ManyArgs :: new (crate :: prisma :: text_channels :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: channel_groups :: IncludeParam > :: into (crate :: prisma :: channel_groups :: voice_channel :: Include :: $ selection_mode (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: voice_channel :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; voice_channel $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: channel_groups :: IncludeParam > :: into (crate :: prisma :: channel_groups :: voice_channel :: Include :: Fetch (crate :: prisma :: voice_channel :: ManyArgs :: new (crate :: prisma :: voice_channel :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: channel_groups :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; servers) => { "servers" } ; (@ field_serde_name ; text_channels) => { "text_channels" } ; (@ field_serde_name ; voice_channel) => { "voice_channel" } ; }
    pub use _include_channel_groups as include;
    pub enum IncludeParam {
        Id(id::Include),
        ServerId(server_id::Include),
        Order(order::Include),
        Name(name::Include),
        Servers(servers::Include),
        TextChannels(text_channels::Include),
        VoiceChannel(voice_channel::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
                Self::TextChannels(data) => data.to_selection(),
                Self::VoiceChannel(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_channel_groups { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: channel_groups struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "server_id")] server_id : i32 , # [serde (rename = "order")] order : i32 , # [serde (rename = "name")] name : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_channel_groups as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "server_id")]
        pub server_id: i32,
        #[serde(rename = "order")]
        pub order: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "servers")]
        pub servers: Option<Box<super::servers::Data>>,
        #[serde(rename = "text_channels")]
        pub text_channels: Option<Vec<super::text_channels::Data>>,
        #[serde(rename = "voice_channel")]
        pub voice_channel: Option<Vec<super::voice_channel::Data>>,
    }
    impl Data {
        pub fn servers(
            &self,
        ) -> Result<&super::servers::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(servers),
                ))
                .map(|v| v.as_ref())
        }
        pub fn text_channels(
            &self,
        ) -> Result<&Vec<super::text_channels::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.text_channels
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(text_channels),
                ))
        }
        pub fn voice_channel(
            &self,
        ) -> Result<&Vec<super::voice_channel::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.voice_channel
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(voice_channel),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Servers(super::servers::UniqueArgs),
        TextChannels(super::text_channels::ManyArgs),
        VoiceChannel(super::voice_channel::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Servers(args) => {
                    let mut selections = < super :: servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(servers::NAME, None, [], selections)
                }
                Self::TextChannels(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        text_channels::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::VoiceChannel(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        voice_channel::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetServerId(i32),
        IncrementServerId(i32),
        DecrementServerId(i32),
        MultiplyServerId(i32),
        DivideServerId(i32),
        SetOrder(i32),
        IncrementOrder(i32),
        DecrementOrder(i32),
        MultiplyOrder(i32),
        DivideOrder(i32),
        SetName(String),
        ConnectServers(super::servers::UniqueWhereParam),
        ConnectTextChannels(Vec<super::text_channels::UniqueWhereParam>),
        DisconnectTextChannels(Vec<super::text_channels::UniqueWhereParam>),
        SetTextChannels(Vec<super::text_channels::UniqueWhereParam>),
        ConnectVoiceChannel(Vec<super::voice_channel::UniqueWhereParam>),
        DisconnectVoiceChannel(Vec<super::voice_channel::UniqueWhereParam>),
        SetVoiceChannel(Vec<super::voice_channel::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectServers(where_param) => (
                    servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectTextChannels(where_params) => (
                    text_channels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channels::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectTextChannels(where_params) => (
                    text_channels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channels::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTextChannels(where_params) => (
                    text_channels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channels::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectVoiceChannel(where_params) => (
                    voice_channel::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::voice_channel::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectVoiceChannel(where_params) => (
                    voice_channel::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::voice_channel::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetVoiceChannel(where_params) => (
                    voice_channel::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::voice_channel::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        ServerId(i32),
        Order(i32),
        Name(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::ServerId(value) => Self::SetServerId(value),
                UncheckedSetParam::Order(value) => Self::SetOrder(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ServerId(::prisma_client_rust::Direction),
        Order(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ServerId(direction) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Order(direction) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        ServerId(_prisma::read_filters::IntFilter),
        Order(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        ServersIs(Vec<super::servers::WhereParam>),
        ServersIsNot(Vec<super::servers::WhereParam>),
        TextChannelsSome(Vec<super::text_channels::WhereParam>),
        TextChannelsEvery(Vec<super::text_channels::WhereParam>),
        TextChannelsNone(Vec<super::text_channels::WhereParam>),
        VoiceChannelSome(Vec<super::voice_channel::WhereParam>),
        VoiceChannelEvery(Vec<super::voice_channel::WhereParam>),
        VoiceChannelNone(Vec<super::voice_channel::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::ServerId(value) => (server_id::NAME, value.into()),
                Self::Order(value) => (order::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::ServersIs(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIsNot(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelsSome(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelsEvery(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelsNone(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VoiceChannelSome(where_params) => (
                    voice_channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VoiceChannelEvery(where_params) => (
                    voice_channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::VoiceChannelNone(where_params) => (
                    voice_channel::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(server_id::NAME),
                ::prisma_client_rust::sel(order::NAME),
                ::prisma_client_rust::sel(name::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            order: i32,
            name: String,
            servers: super::servers::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                servers::connect(servers),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            server_id: i32,
            order: i32,
            name: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                server_id::set(server_id),
                order::set(order),
                name::set(name),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(server_id, order, name, mut _params)| {
                    _params.extend([
                        server_id::set(server_id),
                        order::set(order),
                        name::set(name),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (order, name, servers, mut _params): (
                i32,
                String,
                super::servers::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                servers::connect(servers),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod voice_channel {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "voice_channel";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod server_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetServerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ServerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ServerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ServerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ServerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementServerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementServerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyServerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideServerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod channel_group_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "channel_group_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetChannelGroupId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChannelGroupId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ChannelGroupId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ChannelGroupId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            ChannelGroupId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementChannelGroupId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementChannelGroupId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyChannelGroupId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideChannelGroupId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelGroupId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelGroupId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod order {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "order";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOrder(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Order(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Order(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Order(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Order, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementOrder(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementOrder(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyOrder(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideOrder(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Order(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Order(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod max_users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "max_users";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMaxUsers(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MaxUsers(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MaxUsers(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::MaxUsers(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            MaxUsers,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementMaxUsers(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementMaxUsers(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyMaxUsers(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideMaxUsers(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MaxUsers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MaxUsers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod channel_groups {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "channel_groups";
        pub struct Fetch(pub channel_groups::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<channel_groups::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ChannelGroups(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(channel_groups::UniqueArgs::new())
        }
        pub struct Connect(channel_groups::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChannelGroups(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: channel_groups::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectChannelGroups
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ChannelGroupsIsNull
        }
        pub fn is(value: Vec<channel_groups::WhereParam>) -> WhereParam {
            WhereParam::ChannelGroupsIs(value)
        }
        pub fn is_not(value: Vec<channel_groups::WhereParam>) -> WhereParam {
            WhereParam::ChannelGroupsIsNot(value)
        }
        pub enum Include {
            Select(Vec<channel_groups::SelectParam>),
            Include(Vec<channel_groups::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelGroups(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("channel_groups", None, [], selections)
            }
            pub fn select(nested_selections: Vec<channel_groups::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel_groups::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<channel_groups::SelectParam>),
            Include(Vec<channel_groups::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelGroups(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("channel_groups", None, [], selections)
            }
            pub fn select(nested_selections: Vec<channel_groups::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel_groups::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "servers";
        pub struct Fetch(pub servers::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Servers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(servers::UniqueArgs::new())
        }
        pub struct Connect(servers::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: servers::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIs(value)
        }
        pub fn is_not(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIsNot(value)
        }
        pub enum Include {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Servers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Servers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        order: i32,
        name: String,
        max_users: i32,
        servers: super::servers::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        String,
        i32,
        super::servers::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (order, name, max_users, servers, _params)
    }
    pub fn create_unchecked(
        server_id: i32,
        order: i32,
        name: String,
        max_users: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, i32, Vec<SetParam>) {
        (server_id, order, name, max_users, _params)
    }
    #[macro_export]
    macro_rules ! _select_voice_channel { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: voice_channel :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: voice_channel :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: voice_channel :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: voice_channel :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: voice_channel :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: voice_channel :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , server_id , channel_group_id , order , name , max_users , channel_groups , servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: voice_channel :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: voice_channel :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: voice_channel :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: voice_channel :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "channel_group_id" , "order" , "name" , "max_users" , "channel_groups" , "servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: voice_channel :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; server_id) => { i32 } ; (@ field_type ; channel_group_id) => { Option < i32 > } ; (@ field_type ; order) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; max_users) => { i32 } ; (@ field_type ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < channel_groups :: Data > } ; (@ field_type ; channel_groups) => { Option < crate :: prisma :: channel_groups :: Data > } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "VoiceChannel" , available relations are "id, server_id, channel_group_id, order, name, max_users, channel_groups, servers")) } ; (@ field_module ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: channel_groups :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: id :: Select) } ; (@ selection_field_to_selection_param ; server_id) => { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: server_id :: Select) } ; (@ selection_field_to_selection_param ; channel_group_id) => { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: channel_group_id :: Select) } ; (@ selection_field_to_selection_param ; order) => { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: order :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: name :: Select) } ; (@ selection_field_to_selection_param ; max_users) => { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: max_users :: Select) } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: channel_groups :: Select :: $ selection_mode (crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: channel_groups :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: servers :: Select :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: voice_channel :: SelectParam > :: into (crate :: prisma :: voice_channel :: servers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: voice_channel :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; channel_group_id) => { "channel_group_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; max_users) => { "max_users" } ; (@ field_serde_name ; channel_groups) => { "channel_groups" } ; (@ field_serde_name ; servers) => { "servers" } ; }
    pub use _select_voice_channel as select;
    pub enum SelectParam {
        Id(id::Select),
        ServerId(server_id::Select),
        ChannelGroupId(channel_group_id::Select),
        Order(order::Select),
        Name(name::Select),
        MaxUsers(max_users::Select),
        ChannelGroups(channel_groups::Select),
        Servers(servers::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::ChannelGroupId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::MaxUsers(data) => data.to_selection(),
                Self::ChannelGroups(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_voice_channel { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: voice_channel :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: voice_channel :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: voice_channel :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: voice_channel :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: voice_channel :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: voice_channel :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: voice_channel :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { channel_groups , servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub server_id : i32 , pub channel_group_id : Option < i32 > , pub order : i32 , pub name : String , pub max_users : i32 , $ (pub $ field : crate :: prisma :: voice_channel :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (server_id) , stringify ! (channel_group_id) , stringify ! (order) , stringify ! (name) , stringify ! (max_users)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: voice_channel :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: voice_channel :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: voice_channel :: server_id :: NAME , & self . server_id) ? ; state . serialize_field (crate :: prisma :: voice_channel :: channel_group_id :: NAME , & self . channel_group_id) ? ; state . serialize_field (crate :: prisma :: voice_channel :: order :: NAME , & self . order) ? ; state . serialize_field (crate :: prisma :: voice_channel :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: voice_channel :: max_users :: NAME , & self . max_users) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , server_id , channel_group_id , order , name , max_users } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: voice_channel :: $ field :: NAME) , + , crate :: prisma :: voice_channel :: id :: NAME , crate :: prisma :: voice_channel :: server_id :: NAME , crate :: prisma :: voice_channel :: channel_group_id :: NAME , crate :: prisma :: voice_channel :: order :: NAME , crate :: prisma :: voice_channel :: name :: NAME , crate :: prisma :: voice_channel :: max_users :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: voice_channel :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: voice_channel :: id :: NAME => Ok (Field :: id) , crate :: prisma :: voice_channel :: server_id :: NAME => Ok (Field :: server_id) , crate :: prisma :: voice_channel :: channel_group_id :: NAME => Ok (Field :: channel_group_id) , crate :: prisma :: voice_channel :: order :: NAME => Ok (Field :: order) , crate :: prisma :: voice_channel :: name :: NAME => Ok (Field :: name) , crate :: prisma :: voice_channel :: max_users :: NAME => Ok (Field :: max_users) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut server_id = None ; let mut channel_group_id = None ; let mut order = None ; let mut name = None ; let mut max_users = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: server_id => { if server_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: server_id :: NAME)) ; } server_id = Some (map . next_value () ?) ; } Field :: channel_group_id => { if channel_group_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: channel_group_id :: NAME)) ; } channel_group_id = Some (map . next_value () ?) ; } Field :: order => { if order . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: order :: NAME)) ; } order = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: max_users => { if max_users . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: max_users :: NAME)) ; } max_users = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: voice_channel :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: id :: NAME)) ? ; let server_id = server_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: server_id :: NAME)) ? ; let channel_group_id = channel_group_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: channel_group_id :: NAME)) ? ; let order = order . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: order :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: name :: NAME)) ? ; let max_users = max_users . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: voice_channel :: max_users :: NAME)) ? ; Ok (Data { id , server_id , channel_group_id , order , name , max_users , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "channel_group_id" , "order" , "name" , "max_users" , "channel_groups" , "servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: voice_channel :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < channel_groups :: Data > } ; (@ field_type ; channel_groups) => { Option < crate :: prisma :: channel_groups :: Data > } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "VoiceChannel" , available relations are "channel_groups, servers")) } ; (@ field_module ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: channel_groups :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: voice_channel :: IncludeParam > :: into (crate :: prisma :: voice_channel :: channel_groups :: Include :: $ selection_mode (crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: voice_channel :: IncludeParam > :: into (crate :: prisma :: voice_channel :: channel_groups :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: voice_channel :: IncludeParam > :: into (crate :: prisma :: voice_channel :: servers :: Include :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: voice_channel :: IncludeParam > :: into (crate :: prisma :: voice_channel :: servers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: voice_channel :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; channel_group_id) => { "channel_group_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; max_users) => { "max_users" } ; (@ field_serde_name ; channel_groups) => { "channel_groups" } ; (@ field_serde_name ; servers) => { "servers" } ; }
    pub use _include_voice_channel as include;
    pub enum IncludeParam {
        Id(id::Include),
        ServerId(server_id::Include),
        ChannelGroupId(channel_group_id::Include),
        Order(order::Include),
        Name(name::Include),
        MaxUsers(max_users::Include),
        ChannelGroups(channel_groups::Include),
        Servers(servers::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::ChannelGroupId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::MaxUsers(data) => data.to_selection(),
                Self::ChannelGroups(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_voice_channel { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: voice_channel struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "server_id")] server_id : i32 , # [serde (rename = "channel_group_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] channel_group_id : Option < i32 > , # [serde (rename = "order")] order : i32 , # [serde (rename = "name")] name : String , # [serde (rename = "max_users")] max_users : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_voice_channel as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "server_id")]
        pub server_id: i32,
        #[serde(rename = "channel_group_id")]
        pub channel_group_id: Option<i32>,
        #[serde(rename = "order")]
        pub order: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "max_users")]
        pub max_users: i32,
        #[serde(
            rename = "channel_groups",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub channel_groups: Option<Option<Box<super::channel_groups::Data>>>,
        #[serde(rename = "servers")]
        pub servers: Option<Box<super::servers::Data>>,
    }
    impl Data {
        pub fn channel_groups(
            &self,
        ) -> Result<
            Option<&super::channel_groups::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.channel_groups
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(channel_groups),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn servers(
            &self,
        ) -> Result<&super::servers::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(servers),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        ChannelGroups(super::channel_groups::UniqueArgs),
        Servers(super::servers::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ChannelGroups(args) => {
                    let mut selections = < super :: channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(channel_groups::NAME, None, [], selections)
                }
                Self::Servers(args) => {
                    let mut selections = < super :: servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(servers::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetServerId(i32),
        IncrementServerId(i32),
        DecrementServerId(i32),
        MultiplyServerId(i32),
        DivideServerId(i32),
        SetChannelGroupId(Option<i32>),
        IncrementChannelGroupId(i32),
        DecrementChannelGroupId(i32),
        MultiplyChannelGroupId(i32),
        DivideChannelGroupId(i32),
        SetOrder(i32),
        IncrementOrder(i32),
        DecrementOrder(i32),
        MultiplyOrder(i32),
        DivideOrder(i32),
        SetName(String),
        SetMaxUsers(i32),
        IncrementMaxUsers(i32),
        DecrementMaxUsers(i32),
        MultiplyMaxUsers(i32),
        DivideMaxUsers(i32),
        ConnectChannelGroups(super::channel_groups::UniqueWhereParam),
        DisconnectChannelGroups,
        ConnectServers(super::servers::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMaxUsers(value) => (
                    max_users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementMaxUsers(value) => (
                    max_users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementMaxUsers(value) => (
                    max_users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyMaxUsers(value) => (
                    max_users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideMaxUsers(value) => (
                    max_users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectChannelGroups(where_param) => (
                    channel_groups::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::channel_groups::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectChannelGroups => (
                    channel_groups::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectServers(where_param) => (
                    servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        ServerId(i32),
        ChannelGroupId(Option<i32>),
        Order(i32),
        Name(String),
        MaxUsers(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::ServerId(value) => Self::SetServerId(value),
                UncheckedSetParam::ChannelGroupId(value) => Self::SetChannelGroupId(value),
                UncheckedSetParam::Order(value) => Self::SetOrder(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::MaxUsers(value) => Self::SetMaxUsers(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ServerId(::prisma_client_rust::Direction),
        ChannelGroupId(::prisma_client_rust::Direction),
        Order(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        MaxUsers(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ServerId(direction) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ChannelGroupId(direction) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Order(direction) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MaxUsers(direction) => (
                    max_users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        ServerId(_prisma::read_filters::IntFilter),
        ChannelGroupId(_prisma::read_filters::IntNullableFilter),
        Order(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        MaxUsers(_prisma::read_filters::IntFilter),
        ChannelGroupsIsNull,
        ChannelGroupsIs(Vec<super::channel_groups::WhereParam>),
        ChannelGroupsIsNot(Vec<super::channel_groups::WhereParam>),
        ServersIs(Vec<super::servers::WhereParam>),
        ServersIsNot(Vec<super::servers::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::ServerId(value) => (server_id::NAME, value.into()),
                Self::ChannelGroupId(value) => (channel_group_id::NAME, value.into()),
                Self::Order(value) => (order::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::MaxUsers(value) => (max_users::NAME, value.into()),
                Self::ChannelGroupsIsNull => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ChannelGroupsIs(where_params) => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelGroupsIsNot(where_params) => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIs(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIsNot(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(server_id::NAME),
                ::prisma_client_rust::sel(channel_group_id::NAME),
                ::prisma_client_rust::sel(order::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(max_users::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            order: i32,
            name: String,
            max_users: i32,
            servers: super::servers::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                max_users::set(max_users),
                servers::connect(servers),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            server_id: i32,
            order: i32,
            name: String,
            max_users: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                server_id::set(server_id),
                order::set(order),
                name::set(name),
                max_users::set(max_users),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, String, i32, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(server_id, order, name, max_users, mut _params)| {
                    _params.extend([
                        server_id::set(server_id),
                        order::set(order),
                        name::set(name),
                        max_users::set(max_users),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (order, name, max_users, servers, mut _params): (
                i32,
                String,
                i32,
                super::servers::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                max_users::set(max_users),
                servers::connect(servers),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod text_channels {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "text_channels";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod server_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "server_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetServerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ServerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ServerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ServerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ServerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementServerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementServerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyServerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideServerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ServerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ServerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod channel_group_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "channel_group_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetChannelGroupId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ChannelGroupId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ChannelGroupId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ChannelGroupId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            ChannelGroupId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementChannelGroupId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementChannelGroupId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyChannelGroupId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideChannelGroupId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelGroupId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelGroupId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod order {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "order";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOrder(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Order(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Order(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Order(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Order, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementOrder(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementOrder(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyOrder(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideOrder(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Order(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Order(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod topic {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "topic";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTopic(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Topic(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Topic(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Topic(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Topic,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Topic(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Topic(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod text_channel_messages {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text_channel_messages";
        pub struct Fetch(pub text_channel_messages::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<text_channel_messages::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: text_channel_messages::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: text_channel_messages::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::TextChannelMessages(v)
            }
        }
        pub fn fetch(params: Vec<text_channel_messages::WhereParam>) -> Fetch {
            Fetch(text_channel_messages::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<text_channel_messages::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTextChannelMessages(v)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<text_channel_messages::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<text_channel_messages::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTextChannelMessages(params)
        }
        pub fn set(params: Vec<text_channel_messages::UniqueWhereParam>) -> SetParam {
            SetParam::SetTextChannelMessages(params)
        }
        pub fn some(value: Vec<text_channel_messages::WhereParam>) -> WhereParam {
            WhereParam::TextChannelMessagesSome(value)
        }
        pub fn every(value: Vec<text_channel_messages::WhereParam>) -> WhereParam {
            WhereParam::TextChannelMessagesEvery(value)
        }
        pub fn none(value: Vec<text_channel_messages::WhereParam>) -> WhereParam {
            WhereParam::TextChannelMessagesNone(value)
        }
        pub enum Include {
            Select(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::SelectParam>,
            ),
            Include(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::IncludeParam>,
            ),
            Fetch(text_channel_messages::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TextChannelMessages(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::SelectParam>,
            ),
            Include(
                text_channel_messages::ManyArgs,
                Vec<text_channel_messages::IncludeParam>,
            ),
            Fetch(text_channel_messages::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TextChannelMessages(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: text_channel_messages::ManyArgs,
                nested_selections: Vec<text_channel_messages::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod channel_groups {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "channel_groups";
        pub struct Fetch(pub channel_groups::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<channel_groups::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ChannelGroups(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(channel_groups::UniqueArgs::new())
        }
        pub struct Connect(channel_groups::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectChannelGroups(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: channel_groups::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectChannelGroups
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ChannelGroupsIsNull
        }
        pub fn is(value: Vec<channel_groups::WhereParam>) -> WhereParam {
            WhereParam::ChannelGroupsIs(value)
        }
        pub fn is_not(value: Vec<channel_groups::WhereParam>) -> WhereParam {
            WhereParam::ChannelGroupsIsNot(value)
        }
        pub enum Include {
            Select(Vec<channel_groups::SelectParam>),
            Include(Vec<channel_groups::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ChannelGroups(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("channel_groups", None, [], selections)
            }
            pub fn select(nested_selections: Vec<channel_groups::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel_groups::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<channel_groups::SelectParam>),
            Include(Vec<channel_groups::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ChannelGroups(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("channel_groups", None, [], selections)
            }
            pub fn select(nested_selections: Vec<channel_groups::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<channel_groups::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod servers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "servers";
        pub struct Fetch(pub servers::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<servers::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Servers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(servers::UniqueArgs::new())
        }
        pub struct Connect(servers::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectServers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: servers::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIs(value)
        }
        pub fn is_not(value: Vec<servers::WhereParam>) -> WhereParam {
            WhereParam::ServersIsNot(value)
        }
        pub enum Include {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Servers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<servers::SelectParam>),
            Include(Vec<servers::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Servers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <servers::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("servers", None, [], selections)
            }
            pub fn select(nested_selections: Vec<servers::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<servers::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        order: i32,
        name: String,
        topic: String,
        servers: super::servers::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        String,
        String,
        super::servers::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (order, name, topic, servers, _params)
    }
    pub fn create_unchecked(
        server_id: i32,
        order: i32,
        name: String,
        topic: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, String, Vec<SetParam>) {
        (server_id, order, name, topic, _params)
    }
    #[macro_export]
    macro_rules ! _select_text_channels { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: text_channels :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: text_channels :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , server_id , channel_group_id , order , name , topic , text_channel_messages , channel_groups , servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: text_channels :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: text_channels :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: text_channels :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: text_channels :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "channel_group_id" , "order" , "name" , "topic" , "text_channel_messages" , "channel_groups" , "servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: text_channels :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; server_id) => { i32 } ; (@ field_type ; channel_group_id) => { Option < i32 > } ; (@ field_type ; order) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; topic) => { String } ; (@ field_type ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channel_messages :: Data > } ; (@ field_type ; text_channel_messages) => { Vec < crate :: prisma :: text_channel_messages :: Data > } ; (@ field_type ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < channel_groups :: Data > } ; (@ field_type ; channel_groups) => { Option < crate :: prisma :: channel_groups :: Data > } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TextChannels" , available relations are "id, server_id, channel_group_id, order, name, topic, text_channel_messages, channel_groups, servers")) } ; (@ field_module ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channel_messages :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: channel_groups :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: id :: Select) } ; (@ selection_field_to_selection_param ; server_id) => { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: server_id :: Select) } ; (@ selection_field_to_selection_param ; channel_group_id) => { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: channel_group_id :: Select) } ; (@ selection_field_to_selection_param ; order) => { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: order :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: name :: Select) } ; (@ selection_field_to_selection_param ; topic) => { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: topic :: Select) } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: text_channel_messages :: Select :: $ selection_mode (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channel_messages :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: text_channel_messages :: Select :: Fetch (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: channel_groups :: Select :: $ selection_mode (crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: channel_groups :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: servers :: Select :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channels :: SelectParam > :: into (crate :: prisma :: text_channels :: servers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: text_channels :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; channel_group_id) => { "channel_group_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; topic) => { "topic" } ; (@ field_serde_name ; text_channel_messages) => { "text_channel_messages" } ; (@ field_serde_name ; channel_groups) => { "channel_groups" } ; (@ field_serde_name ; servers) => { "servers" } ; }
    pub use _select_text_channels as select;
    pub enum SelectParam {
        Id(id::Select),
        ServerId(server_id::Select),
        ChannelGroupId(channel_group_id::Select),
        Order(order::Select),
        Name(name::Select),
        Topic(topic::Select),
        TextChannelMessages(text_channel_messages::Select),
        ChannelGroups(channel_groups::Select),
        Servers(servers::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::ChannelGroupId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Topic(data) => data.to_selection(),
                Self::TextChannelMessages(data) => data.to_selection(),
                Self::ChannelGroups(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_text_channels { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: text_channels :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: text_channels :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: text_channels :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channels :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: text_channels :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { text_channel_messages , channel_groups , servers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub server_id : i32 , pub channel_group_id : Option < i32 > , pub order : i32 , pub name : String , pub topic : String , $ (pub $ field : crate :: prisma :: text_channels :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (server_id) , stringify ! (channel_group_id) , stringify ! (order) , stringify ! (name) , stringify ! (topic)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: text_channels :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: text_channels :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: text_channels :: server_id :: NAME , & self . server_id) ? ; state . serialize_field (crate :: prisma :: text_channels :: channel_group_id :: NAME , & self . channel_group_id) ? ; state . serialize_field (crate :: prisma :: text_channels :: order :: NAME , & self . order) ? ; state . serialize_field (crate :: prisma :: text_channels :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: text_channels :: topic :: NAME , & self . topic) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , server_id , channel_group_id , order , name , topic } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: text_channels :: $ field :: NAME) , + , crate :: prisma :: text_channels :: id :: NAME , crate :: prisma :: text_channels :: server_id :: NAME , crate :: prisma :: text_channels :: channel_group_id :: NAME , crate :: prisma :: text_channels :: order :: NAME , crate :: prisma :: text_channels :: name :: NAME , crate :: prisma :: text_channels :: topic :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: text_channels :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: text_channels :: id :: NAME => Ok (Field :: id) , crate :: prisma :: text_channels :: server_id :: NAME => Ok (Field :: server_id) , crate :: prisma :: text_channels :: channel_group_id :: NAME => Ok (Field :: channel_group_id) , crate :: prisma :: text_channels :: order :: NAME => Ok (Field :: order) , crate :: prisma :: text_channels :: name :: NAME => Ok (Field :: name) , crate :: prisma :: text_channels :: topic :: NAME => Ok (Field :: topic) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut server_id = None ; let mut channel_group_id = None ; let mut order = None ; let mut name = None ; let mut topic = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: server_id => { if server_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: server_id :: NAME)) ; } server_id = Some (map . next_value () ?) ; } Field :: channel_group_id => { if channel_group_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: channel_group_id :: NAME)) ; } channel_group_id = Some (map . next_value () ?) ; } Field :: order => { if order . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: order :: NAME)) ; } order = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: topic => { if topic . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: topic :: NAME)) ; } topic = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channels :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: id :: NAME)) ? ; let server_id = server_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: server_id :: NAME)) ? ; let channel_group_id = channel_group_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: channel_group_id :: NAME)) ? ; let order = order . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: order :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: name :: NAME)) ? ; let topic = topic . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channels :: topic :: NAME)) ? ; Ok (Data { id , server_id , channel_group_id , order , name , topic , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "server_id" , "channel_group_id" , "order" , "name" , "topic" , "text_channel_messages" , "channel_groups" , "servers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: text_channels :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < text_channel_messages :: Data > } ; (@ field_type ; text_channel_messages) => { Vec < crate :: prisma :: text_channel_messages :: Data > } ; (@ field_type ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < channel_groups :: Data > } ; (@ field_type ; channel_groups) => { Option < crate :: prisma :: channel_groups :: Data > } ; (@ field_type ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { servers :: Data } ; (@ field_type ; servers) => { crate :: prisma :: servers :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TextChannels" , available relations are "text_channel_messages, channel_groups, servers")) } ; (@ field_module ; text_channel_messages : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channel_messages :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; channel_groups : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: channel_groups :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; servers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: servers :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channels :: IncludeParam > :: into (crate :: prisma :: text_channels :: text_channel_messages :: Include :: $ selection_mode (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: text_channel_messages :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channel_messages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channels :: IncludeParam > :: into (crate :: prisma :: text_channels :: text_channel_messages :: Include :: Fetch (crate :: prisma :: text_channel_messages :: ManyArgs :: new (crate :: prisma :: text_channel_messages :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channels :: IncludeParam > :: into (crate :: prisma :: text_channels :: channel_groups :: Include :: $ selection_mode (crate :: prisma :: channel_groups :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; channel_groups $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channels :: IncludeParam > :: into (crate :: prisma :: text_channels :: channel_groups :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channels :: IncludeParam > :: into (crate :: prisma :: text_channels :: servers :: Include :: $ selection_mode (crate :: prisma :: servers :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; servers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channels :: IncludeParam > :: into (crate :: prisma :: text_channels :: servers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: text_channels :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; server_id) => { "server_id" } ; (@ field_serde_name ; channel_group_id) => { "channel_group_id" } ; (@ field_serde_name ; order) => { "order" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; topic) => { "topic" } ; (@ field_serde_name ; text_channel_messages) => { "text_channel_messages" } ; (@ field_serde_name ; channel_groups) => { "channel_groups" } ; (@ field_serde_name ; servers) => { "servers" } ; }
    pub use _include_text_channels as include;
    pub enum IncludeParam {
        Id(id::Include),
        ServerId(server_id::Include),
        ChannelGroupId(channel_group_id::Include),
        Order(order::Include),
        Name(name::Include),
        Topic(topic::Include),
        TextChannelMessages(text_channel_messages::Include),
        ChannelGroups(channel_groups::Include),
        Servers(servers::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ServerId(data) => data.to_selection(),
                Self::ChannelGroupId(data) => data.to_selection(),
                Self::Order(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Topic(data) => data.to_selection(),
                Self::TextChannelMessages(data) => data.to_selection(),
                Self::ChannelGroups(data) => data.to_selection(),
                Self::Servers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_text_channels { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: text_channels struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "server_id")] server_id : i32 , # [serde (rename = "channel_group_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] channel_group_id : Option < i32 > , # [serde (rename = "order")] order : i32 , # [serde (rename = "name")] name : String , # [serde (rename = "topic")] topic : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_text_channels as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "server_id")]
        pub server_id: i32,
        #[serde(rename = "channel_group_id")]
        pub channel_group_id: Option<i32>,
        #[serde(rename = "order")]
        pub order: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "topic")]
        pub topic: String,
        #[serde(rename = "text_channel_messages")]
        pub text_channel_messages: Option<Vec<super::text_channel_messages::Data>>,
        #[serde(
            rename = "channel_groups",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub channel_groups: Option<Option<Box<super::channel_groups::Data>>>,
        #[serde(rename = "servers")]
        pub servers: Option<Box<super::servers::Data>>,
    }
    impl Data {
        pub fn text_channel_messages(
            &self,
        ) -> Result<
            &Vec<super::text_channel_messages::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.text_channel_messages.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    text_channel_messages
                )),
            )
        }
        pub fn channel_groups(
            &self,
        ) -> Result<
            Option<&super::channel_groups::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.channel_groups
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(channel_groups),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn servers(
            &self,
        ) -> Result<&super::servers::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.servers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(servers),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        TextChannelMessages(super::text_channel_messages::ManyArgs),
        ChannelGroups(super::channel_groups::UniqueArgs),
        Servers(super::servers::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::TextChannelMessages(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        text_channel_messages::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::ChannelGroups(args) => {
                    let mut selections = < super :: channel_groups :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(channel_groups::NAME, None, [], selections)
                }
                Self::Servers(args) => {
                    let mut selections = < super :: servers :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(servers::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetServerId(i32),
        IncrementServerId(i32),
        DecrementServerId(i32),
        MultiplyServerId(i32),
        DivideServerId(i32),
        SetChannelGroupId(Option<i32>),
        IncrementChannelGroupId(i32),
        DecrementChannelGroupId(i32),
        MultiplyChannelGroupId(i32),
        DivideChannelGroupId(i32),
        SetOrder(i32),
        IncrementOrder(i32),
        DecrementOrder(i32),
        MultiplyOrder(i32),
        DivideOrder(i32),
        SetName(String),
        SetTopic(String),
        ConnectTextChannelMessages(Vec<super::text_channel_messages::UniqueWhereParam>),
        DisconnectTextChannelMessages(Vec<super::text_channel_messages::UniqueWhereParam>),
        SetTextChannelMessages(Vec<super::text_channel_messages::UniqueWhereParam>),
        ConnectChannelGroups(super::channel_groups::UniqueWhereParam),
        DisconnectChannelGroups,
        ConnectServers(super::servers::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideServerId(value) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideChannelGroupId(value) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideOrder(value) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTopic(value) => (
                    topic::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectTextChannelMessages(where_params) => (
                    text_channel_messages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channel_messages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectTextChannelMessages(where_params) => (
                    text_channel_messages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channel_messages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetTextChannelMessages(where_params) => (
                    text_channel_messages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::text_channel_messages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectChannelGroups(where_param) => (
                    channel_groups::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::channel_groups::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectChannelGroups => (
                    channel_groups::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectServers(where_param) => (
                    servers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::servers::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        ServerId(i32),
        ChannelGroupId(Option<i32>),
        Order(i32),
        Name(String),
        Topic(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::ServerId(value) => Self::SetServerId(value),
                UncheckedSetParam::ChannelGroupId(value) => Self::SetChannelGroupId(value),
                UncheckedSetParam::Order(value) => Self::SetOrder(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Topic(value) => Self::SetTopic(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ServerId(::prisma_client_rust::Direction),
        ChannelGroupId(::prisma_client_rust::Direction),
        Order(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Topic(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ServerId(direction) => (
                    server_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ChannelGroupId(direction) => (
                    channel_group_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Order(direction) => (
                    order::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Topic(direction) => (
                    topic::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        ServerId(_prisma::read_filters::IntFilter),
        ChannelGroupId(_prisma::read_filters::IntNullableFilter),
        Order(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        Topic(_prisma::read_filters::StringFilter),
        TextChannelMessagesSome(Vec<super::text_channel_messages::WhereParam>),
        TextChannelMessagesEvery(Vec<super::text_channel_messages::WhereParam>),
        TextChannelMessagesNone(Vec<super::text_channel_messages::WhereParam>),
        ChannelGroupsIsNull,
        ChannelGroupsIs(Vec<super::channel_groups::WhereParam>),
        ChannelGroupsIsNot(Vec<super::channel_groups::WhereParam>),
        ServersIs(Vec<super::servers::WhereParam>),
        ServersIsNot(Vec<super::servers::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::ServerId(value) => (server_id::NAME, value.into()),
                Self::ChannelGroupId(value) => (channel_group_id::NAME, value.into()),
                Self::Order(value) => (order::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Topic(value) => (topic::NAME, value.into()),
                Self::TextChannelMessagesSome(where_params) => (
                    text_channel_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelMessagesEvery(where_params) => (
                    text_channel_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelMessagesNone(where_params) => (
                    text_channel_messages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelGroupsIsNull => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ChannelGroupsIs(where_params) => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChannelGroupsIsNot(where_params) => (
                    channel_groups::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIs(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ServersIsNot(where_params) => (
                    servers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(server_id::NAME),
                ::prisma_client_rust::sel(channel_group_id::NAME),
                ::prisma_client_rust::sel(order::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(topic::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            order: i32,
            name: String,
            topic: String,
            servers: super::servers::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                topic::set(topic),
                servers::connect(servers),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            server_id: i32,
            order: i32,
            name: String,
            topic: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                server_id::set(server_id),
                order::set(order),
                name::set(name),
                topic::set(topic),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(i32, i32, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(server_id, order, name, topic, mut _params)| {
                    _params.extend([
                        server_id::set(server_id),
                        order::set(order),
                        name::set(name),
                        topic::set(topic),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (order, name, topic, servers, mut _params): (
                i32,
                String,
                String,
                super::servers::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                order::set(order),
                name::set(name),
                topic::set(topic),
                servers::connect(servers),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod text_channel_messages {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "text_channel_messages";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod sender_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "sender_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSenderId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SenderId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SenderId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SenderId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SenderId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSenderId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSenderId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySenderId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSenderId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SenderId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SenderId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod text_channel_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text_channel_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTextChannelId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TextChannelId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TextChannelId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TextChannelId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            TextChannelId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTextChannelId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTextChannelId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTextChannelId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTextChannelId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TextChannelId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TextChannelId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod r#type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "type";
        pub struct Set(pub self::MessageType);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Type(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::MessageType) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Type(direction)
        }
        pub fn equals(value: self::MessageType) -> WhereParam {
            WhereParam::Type(_prisma::read_filters::message_typeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::message_typeFilter,
            Type,
            {
                fn in_vec(_: Vec<super::super::MessageType>) -> InVec;
                fn not_in_vec(_: Vec<super::super::MessageType>) -> NotInVec;
                fn not(_: super::super::MessageType) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Type(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Type(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod payload {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "payload";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPayload(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Payload(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Payload(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Payload(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Payload,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Payload(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Payload(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod deleted_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "deleted_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDeletedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DeletedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DeletedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::DeletedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            DeletedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DeletedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DeletedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod text_channels {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text_channels";
        pub struct Fetch(pub text_channels::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<text_channels::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::TextChannels(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(text_channels::UniqueArgs::new())
        }
        pub struct Connect(text_channels::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectTextChannels(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: text_channels::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsIs(value)
        }
        pub fn is_not(value: Vec<text_channels::WhereParam>) -> WhereParam {
            WhereParam::TextChannelsIsNot(value)
        }
        pub enum Include {
            Select(Vec<text_channels::SelectParam>),
            Include(Vec<text_channels::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TextChannels(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("text_channels", None, [], selections)
            }
            pub fn select(nested_selections: Vec<text_channels::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<text_channels::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<text_channels::SelectParam>),
            Include(Vec<text_channels::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TextChannels(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new("text_channels", None, [], selections)
            }
            pub fn select(nested_selections: Vec<text_channels::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<text_channels::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        r#type: super::MessageType,
        payload: String,
        deleted_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        text_channels: super::text_channels::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::MessageType,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        super::text_channels::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (r#type, payload, deleted_at, text_channels, users, _params)
    }
    pub fn create_unchecked(
        sender_id: i32,
        text_channel_id: i32,
        r#type: super::MessageType,
        payload: String,
        deleted_at: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        i32,
        super::MessageType,
        String,
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        Vec<SetParam>,
    ) {
        (
            sender_id,
            text_channel_id,
            r#type,
            payload,
            deleted_at,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_text_channel_messages { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: text_channel_messages :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channel_messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: text_channel_messages :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: text_channel_messages :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channel_messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: text_channel_messages :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , sender_id , text_channel_id , r#type , payload , created_at , deleted_at , text_channels , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: text_channel_messages :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: text_channel_messages :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: text_channel_messages :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: text_channel_messages :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "sender_id" , "text_channel_id" , "type" , "payload" , "created_at" , "deleted_at" , "text_channels" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: text_channel_messages :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; sender_id) => { i32 } ; (@ field_type ; text_channel_id) => { i32 } ; (@ field_type ; r#type) => { crate :: prisma :: MessageType } ; (@ field_type ; payload) => { String } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; deleted_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { text_channels :: Data } ; (@ field_type ; text_channels) => { crate :: prisma :: text_channels :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TextChannelMessages" , available relations are "id, sender_id, text_channel_id, r#type, payload, created_at, deleted_at, text_channels, users")) } ; (@ field_module ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channels :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: id :: Select) } ; (@ selection_field_to_selection_param ; sender_id) => { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: sender_id :: Select) } ; (@ selection_field_to_selection_param ; text_channel_id) => { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: text_channel_id :: Select) } ; (@ selection_field_to_selection_param ; r#type) => { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: r#type :: Select) } ; (@ selection_field_to_selection_param ; payload) => { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: payload :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: created_at :: Select) } ; (@ selection_field_to_selection_param ; deleted_at) => { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: deleted_at :: Select) } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: text_channels :: Select :: $ selection_mode (crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: text_channels :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channel_messages :: SelectParam > :: into (crate :: prisma :: text_channel_messages :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: text_channel_messages :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; sender_id) => { "sender_id" } ; (@ field_serde_name ; text_channel_id) => { "text_channel_id" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; payload) => { "payload" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; deleted_at) => { "deleted_at" } ; (@ field_serde_name ; text_channels) => { "text_channels" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_text_channel_messages as select;
    pub enum SelectParam {
        Id(id::Select),
        SenderId(sender_id::Select),
        TextChannelId(text_channel_id::Select),
        Type(r#type::Select),
        Payload(payload::Select),
        CreatedAt(created_at::Select),
        DeletedAt(deleted_at::Select),
        TextChannels(text_channels::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SenderId(data) => data.to_selection(),
                Self::TextChannelId(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::Payload(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::DeletedAt(data) => data.to_selection(),
                Self::TextChannels(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_text_channel_messages { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: text_channel_messages :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channel_messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: text_channel_messages :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: text_channel_messages :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: text_channel_messages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: text_channel_messages :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: text_channel_messages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { text_channels , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub sender_id : i32 , pub text_channel_id : i32 , pub r#type : crate :: prisma :: MessageType , pub payload : String , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub deleted_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: prisma :: text_channel_messages :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (sender_id) , stringify ! (text_channel_id) , stringify ! (r#type) , stringify ! (payload) , stringify ! (created_at) , stringify ! (deleted_at)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: text_channel_messages :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: text_channel_messages :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: text_channel_messages :: sender_id :: NAME , & self . sender_id) ? ; state . serialize_field (crate :: prisma :: text_channel_messages :: text_channel_id :: NAME , & self . text_channel_id) ? ; state . serialize_field (crate :: prisma :: text_channel_messages :: r#type :: NAME , & self . r#type) ? ; state . serialize_field (crate :: prisma :: text_channel_messages :: payload :: NAME , & self . payload) ? ; state . serialize_field (crate :: prisma :: text_channel_messages :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: text_channel_messages :: deleted_at :: NAME , & self . deleted_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , sender_id , text_channel_id , r#type , payload , created_at , deleted_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: text_channel_messages :: $ field :: NAME) , + , crate :: prisma :: text_channel_messages :: id :: NAME , crate :: prisma :: text_channel_messages :: sender_id :: NAME , crate :: prisma :: text_channel_messages :: text_channel_id :: NAME , crate :: prisma :: text_channel_messages :: r#type :: NAME , crate :: prisma :: text_channel_messages :: payload :: NAME , crate :: prisma :: text_channel_messages :: created_at :: NAME , crate :: prisma :: text_channel_messages :: deleted_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: text_channel_messages :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: text_channel_messages :: id :: NAME => Ok (Field :: id) , crate :: prisma :: text_channel_messages :: sender_id :: NAME => Ok (Field :: sender_id) , crate :: prisma :: text_channel_messages :: text_channel_id :: NAME => Ok (Field :: text_channel_id) , crate :: prisma :: text_channel_messages :: r#type :: NAME => Ok (Field :: r#type) , crate :: prisma :: text_channel_messages :: payload :: NAME => Ok (Field :: payload) , crate :: prisma :: text_channel_messages :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: text_channel_messages :: deleted_at :: NAME => Ok (Field :: deleted_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut sender_id = None ; let mut text_channel_id = None ; let mut r#type = None ; let mut payload = None ; let mut created_at = None ; let mut deleted_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: sender_id => { if sender_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: sender_id :: NAME)) ; } sender_id = Some (map . next_value () ?) ; } Field :: text_channel_id => { if text_channel_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: text_channel_id :: NAME)) ; } text_channel_id = Some (map . next_value () ?) ; } Field :: r#type => { if r#type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: r#type :: NAME)) ; } r#type = Some (map . next_value () ?) ; } Field :: payload => { if payload . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: payload :: NAME)) ; } payload = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: deleted_at => { if deleted_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: deleted_at :: NAME)) ; } deleted_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: text_channel_messages :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: id :: NAME)) ? ; let sender_id = sender_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: sender_id :: NAME)) ? ; let text_channel_id = text_channel_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: text_channel_id :: NAME)) ? ; let r#type = r#type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: r#type :: NAME)) ? ; let payload = payload . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: payload :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: created_at :: NAME)) ? ; let deleted_at = deleted_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: text_channel_messages :: deleted_at :: NAME)) ? ; Ok (Data { id , sender_id , text_channel_id , r#type , payload , created_at , deleted_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "sender_id" , "text_channel_id" , "type" , "payload" , "created_at" , "deleted_at" , "text_channels" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: text_channel_messages :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { text_channels :: Data } ; (@ field_type ; text_channels) => { crate :: prisma :: text_channels :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TextChannelMessages" , available relations are "text_channels, users")) } ; (@ field_module ; text_channels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: text_channels :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channel_messages :: IncludeParam > :: into (crate :: prisma :: text_channel_messages :: text_channels :: Include :: $ selection_mode (crate :: prisma :: text_channels :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; text_channels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channel_messages :: IncludeParam > :: into (crate :: prisma :: text_channel_messages :: text_channels :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: text_channel_messages :: IncludeParam > :: into (crate :: prisma :: text_channel_messages :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: text_channel_messages :: IncludeParam > :: into (crate :: prisma :: text_channel_messages :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: text_channel_messages :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; sender_id) => { "sender_id" } ; (@ field_serde_name ; text_channel_id) => { "text_channel_id" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; payload) => { "payload" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; deleted_at) => { "deleted_at" } ; (@ field_serde_name ; text_channels) => { "text_channels" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_text_channel_messages as include;
    pub enum IncludeParam {
        Id(id::Include),
        SenderId(sender_id::Include),
        TextChannelId(text_channel_id::Include),
        Type(r#type::Include),
        Payload(payload::Include),
        CreatedAt(created_at::Include),
        DeletedAt(deleted_at::Include),
        TextChannels(text_channels::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SenderId(data) => data.to_selection(),
                Self::TextChannelId(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::Payload(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::DeletedAt(data) => data.to_selection(),
                Self::TextChannels(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_text_channel_messages { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: text_channel_messages struct $ struct_name { # [serde (rename = "id")] id : i32 , # [serde (rename = "sender_id")] sender_id : i32 , # [serde (rename = "text_channel_id")] text_channel_id : i32 , # [serde (rename = "type")] r#type : crate :: prisma :: MessageType , # [serde (rename = "payload")] payload : String , # [serde (rename = "created_at")] created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "deleted_at")] deleted_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_text_channel_messages as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "sender_id")]
        pub sender_id: i32,
        #[serde(rename = "text_channel_id")]
        pub text_channel_id: i32,
        #[serde(rename = "type")]
        pub r#type: super::MessageType,
        #[serde(rename = "payload")]
        pub payload: String,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "deleted_at")]
        pub deleted_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "text_channels")]
        pub text_channels: Option<Box<super::text_channels::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn text_channels(
            &self,
        ) -> Result<&super::text_channels::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.text_channels
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(text_channels),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        TextChannels(super::text_channels::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::TextChannels(args) => {
                    let mut selections = < super :: text_channels :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(text_channels::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSenderId(i32),
        IncrementSenderId(i32),
        DecrementSenderId(i32),
        MultiplySenderId(i32),
        DivideSenderId(i32),
        SetTextChannelId(i32),
        IncrementTextChannelId(i32),
        DecrementTextChannelId(i32),
        MultiplyTextChannelId(i32),
        DivideTextChannelId(i32),
        SetType(super::MessageType),
        SetPayload(String),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetDeletedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ConnectTextChannels(super::text_channels::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSenderId(value) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideTextChannelId(value) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetType(value) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetPayload(value) => (
                    payload::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetDeletedAt(value) => (
                    deleted_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::ConnectTextChannels(where_param) => (
                    text_channels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::text_channels::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SenderId(i32),
        TextChannelId(i32),
        Type(super::MessageType),
        Payload(String),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        DeletedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SenderId(value) => Self::SetSenderId(value),
                UncheckedSetParam::TextChannelId(value) => Self::SetTextChannelId(value),
                UncheckedSetParam::Type(value) => Self::SetType(value),
                UncheckedSetParam::Payload(value) => Self::SetPayload(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::DeletedAt(value) => Self::SetDeletedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SenderId(::prisma_client_rust::Direction),
        TextChannelId(::prisma_client_rust::Direction),
        Type(::prisma_client_rust::Direction),
        Payload(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        DeletedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SenderId(direction) => (
                    sender_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TextChannelId(direction) => (
                    text_channel_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Type(direction) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Payload(direction) => (
                    payload::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DeletedAt(direction) => (
                    deleted_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        SenderId(_prisma::read_filters::IntFilter),
        TextChannelId(_prisma::read_filters::IntFilter),
        Type(_prisma::read_filters::message_typeFilter),
        Payload(_prisma::read_filters::StringFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        DeletedAt(_prisma::read_filters::DateTimeFilter),
        TextChannelsIs(Vec<super::text_channels::WhereParam>),
        TextChannelsIsNot(Vec<super::text_channels::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SenderId(value) => (sender_id::NAME, value.into()),
                Self::TextChannelId(value) => (text_channel_id::NAME, value.into()),
                Self::Type(value) => (r#type::NAME, value.into()),
                Self::Payload(value) => (payload::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::DeletedAt(value) => (deleted_at::NAME, value.into()),
                Self::TextChannelsIs(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::TextChannelsIsNot(where_params) => (
                    text_channels::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(sender_id::NAME),
                ::prisma_client_rust::sel(text_channel_id::NAME),
                ::prisma_client_rust::sel(r#type::NAME),
                ::prisma_client_rust::sel(payload::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(deleted_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            r#type: super::MessageType,
            payload: String,
            deleted_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            text_channels: super::text_channels::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                r#type::set(r#type),
                payload::set(payload),
                deleted_at::set(deleted_at),
                text_channels::connect(text_channels),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            sender_id: i32,
            text_channel_id: i32,
            r#type: super::MessageType,
            payload: String,
            deleted_at: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                sender_id::set(sender_id),
                text_channel_id::set(text_channel_id),
                r#type::set(r#type),
                payload::set(payload),
                deleted_at::set(deleted_at),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                i32,
                i32,
                super::MessageType,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(
                    |(sender_id, text_channel_id, r#type, payload, deleted_at, mut _params)| {
                        _params.extend([
                            sender_id::set(sender_id),
                            text_channel_id::set(text_channel_id),
                            r#type::set(r#type),
                            payload::set(payload),
                            deleted_at::set(deleted_at),
                        ]);
                        _params
                    },
                )
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (r#type, payload, deleted_at, text_channels, users, mut _params): (
                super::MessageType,
                String,
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                super::text_channels::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                r#type::set(r#type),
                payload::set(payload),
                deleted_at::set(deleted_at),
                text_channels::connect(text_channels),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
        pub fn find_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::FindRaw<'a, Types, T> {
            ::prisma_client_rust::FindRaw::new(self.client)
        }
        pub fn aggregate_raw<T: ::prisma_client_rust::Data>(
            self,
        ) -> ::prisma_client_rust::AggregateRaw<'a, Types, T> {
            ::prisma_client_rust::AggregateRaw::new(self.client)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn users(&self) -> super::users::Actions {
            super::users::Actions { client: &self.0 }
        }
        pub fn user_friends(&self) -> super::user_friends::Actions {
            super::user_friends::Actions { client: &self.0 }
        }
        pub fn message(&self) -> super::message::Actions {
            super::message::Actions { client: &self.0 }
        }
        pub fn access_token(&self) -> super::access_token::Actions {
            super::access_token::Actions { client: &self.0 }
        }
        pub fn users_servers(&self) -> super::users_servers::Actions {
            super::users_servers::Actions { client: &self.0 }
        }
        pub fn servers(&self) -> super::servers::Actions {
            super::servers::Actions { client: &self.0 }
        }
        pub fn server_tags(&self) -> super::server_tags::Actions {
            super::server_tags::Actions { client: &self.0 }
        }
        pub fn user_server_tags(&self) -> super::user_server_tags::Actions {
            super::user_server_tags::Actions { client: &self.0 }
        }
        pub fn channel_groups(&self) -> super::channel_groups::Actions {
            super::channel_groups::Actions { client: &self.0 }
        }
        pub fn voice_channel(&self) -> super::voice_channel::Actions {
            super::voice_channel::Actions { client: &self.0 }
        }
        pub fn text_channels(&self) -> super::text_channels::Actions {
            super::text_channels::Actions { client: &self.0 }
        }
        pub fn text_channel_messages(&self) -> super::text_channel_messages::Actions {
            super::text_channel_messages::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum AccessTokenScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "access_token")]
        AccessToken,
        #[serde(rename = "refresh_token")]
        RefreshToken,
    }
    impl ToString for AccessTokenScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::AccessToken => "access_token".to_string(),
                Self::RefreshToken => "refresh_token".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ChannelGroupsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "server_id")]
        ServerId,
        #[serde(rename = "order")]
        Order,
        #[serde(rename = "name")]
        Name,
    }
    impl ToString for ChannelGroupsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ServerId => "server_id".to_string(),
                Self::Order => "order".to_string(),
                Self::Name => "name".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum MessageScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "sender_id")]
        SenderId,
        #[serde(rename = "receiver_id")]
        ReceiverId,
        #[serde(rename = "type")]
        Type,
        #[serde(rename = "payload")]
        Payload,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "deleted_at")]
        DeletedAt,
    }
    impl ToString for MessageScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SenderId => "sender_id".to_string(),
                Self::ReceiverId => "receiver_id".to_string(),
                Self::Type => "type".to_string(),
                Self::Payload => "payload".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::DeletedAt => "deleted_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ServerTagsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "server_id")]
        ServerId,
        #[serde(rename = "order")]
        Order,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "Color")]
        Color,
    }
    impl ToString for ServerTagsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ServerId => "server_id".to_string(),
                Self::Order => "order".to_string(),
                Self::Name => "name".to_string(),
                Self::Color => "Color".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ServersScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "text_channel_id")]
        TextChannelId,
        #[serde(rename = "description")]
        Description,
    }
    impl ToString for ServersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::TextChannelId => "text_channel_id".to_string(),
                Self::Description => "description".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TextChannelMessagesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "sender_id")]
        SenderId,
        #[serde(rename = "text_channel_id")]
        TextChannelId,
        #[serde(rename = "type")]
        Type,
        #[serde(rename = "payload")]
        Payload,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "deleted_at")]
        DeletedAt,
    }
    impl ToString for TextChannelMessagesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SenderId => "sender_id".to_string(),
                Self::TextChannelId => "text_channel_id".to_string(),
                Self::Type => "type".to_string(),
                Self::Payload => "payload".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::DeletedAt => "deleted_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TextChannelsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "server_id")]
        ServerId,
        #[serde(rename = "channel_group_id")]
        ChannelGroupId,
        #[serde(rename = "order")]
        Order,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "topic")]
        Topic,
    }
    impl ToString for TextChannelsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ServerId => "server_id".to_string(),
                Self::ChannelGroupId => "channel_group_id".to_string(),
                Self::Order => "order".to_string(),
                Self::Name => "name".to_string(),
                Self::Topic => "topic".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserFriendsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "user_1_id")]
        User1Id,
        #[serde(rename = "user_2_id")]
        User2Id,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for UserFriendsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::User1Id => "user_1_id".to_string(),
                Self::User2Id => "user_2_id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UserServerTagsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "server_tag_id")]
        ServerTagId,
        #[serde(rename = "user_server_id")]
        UserServerId,
    }
    impl ToString for UserServerTagsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ServerTagId => "server_tag_id".to_string(),
                Self::UserServerId => "user_server_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UsersScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "user_name")]
        UserName,
        #[serde(rename = "password")]
        Password,
        #[serde(rename = "display_name")]
        DisplayName,
        #[serde(rename = "first_name")]
        FirstName,
        #[serde(rename = "last_name")]
        LastName,
        #[serde(rename = "image")]
        Image,
        #[serde(rename = "status")]
        Status,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "privacy_level")]
        PrivacyLevel,
        #[serde(rename = "role")]
        Role,
        #[serde(rename = "created_at")]
        CreatedAt,
    }
    impl ToString for UsersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::UserName => "user_name".to_string(),
                Self::Password => "password".to_string(),
                Self::DisplayName => "display_name".to_string(),
                Self::FirstName => "first_name".to_string(),
                Self::LastName => "last_name".to_string(),
                Self::Image => "image".to_string(),
                Self::Status => "status".to_string(),
                Self::Email => "email".to_string(),
                Self::PrivacyLevel => "privacy_level".to_string(),
                Self::Role => "role".to_string(),
                Self::CreatedAt => "created_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UsersServersScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "server_id")]
        ServerId,
        #[serde(rename = "display_name")]
        DisplayName,
        #[serde(rename = "role")]
        Role,
    }
    impl ToString for UsersServersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::ServerId => "server_id".to_string(),
                Self::DisplayName => "display_name".to_string(),
                Self::Role => "role".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum VoiceChannelScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "server_id")]
        ServerId,
        #[serde(rename = "channel_group_id")]
        ChannelGroupId,
        #[serde(rename = "order")]
        Order,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "max_users")]
        MaxUsers,
    }
    impl ToString for VoiceChannelScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ServerId => "server_id".to_string(),
                Self::ChannelGroupId => "channel_group_id".to_string(),
                Self::Order => "order".to_string(),
                Self::Name => "name".to_string(),
                Self::MaxUsers => "max_users".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum IntNullableFilter {
            Equals(Option<i32>),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(Option<i32>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeNullableFilter {
            Equals(
                Option<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(
                Option<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum users_statusFilter {
            Equals(super::super::UsersStatus),
            InVec(Vec<super::super::UsersStatus>),
            NotInVec(Vec<super::super::UsersStatus>),
            Not(super::super::UsersStatus),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for users_statusFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum colorsFilter {
            Equals(super::super::Colors),
            InVec(Vec<super::super::Colors>),
            NotInVec(Vec<super::super::Colors>),
            Not(super::super::Colors),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for colorsFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum users_privacy_levelFilter {
            Equals(super::super::UsersPrivacyLevel),
            InVec(Vec<super::super::UsersPrivacyLevel>),
            NotInVec(Vec<super::super::UsersPrivacyLevel>),
            Not(super::super::UsersPrivacyLevel),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for users_privacy_levelFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum users_roleFilter {
            Equals(super::super::UsersRole),
            InVec(Vec<super::super::UsersRole>),
            NotInVec(Vec<super::super::UsersRole>),
            Not(super::super::UsersRole),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for users_roleFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum server_roleFilter {
            Equals(super::super::ServerRole),
            InVec(Vec<super::super::ServerRole>),
            NotInVec(Vec<super::super::ServerRole>),
            Not(super::super::ServerRole),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for server_roleFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum message_typeFilter {
            Equals(super::super::MessageType),
            InVec(Vec<super::super::MessageType>),
            NotInVec(Vec<super::super::MessageType>),
            Not(super::super::MessageType),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for message_typeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum UsersStatus {
    #[serde(rename = "Online")]
    Online,
    #[serde(rename = "Away")]
    Away,
    #[serde(rename = "DoNotDisturb")]
    DoNotDisturb,
    #[serde(rename = "Offline")]
    Offline,
}
impl ToString for UsersStatus {
    fn to_string(&self) -> String {
        match self {
            Self::Online => "Online".to_string(),
            Self::Away => "Away".to_string(),
            Self::DoNotDisturb => "DoNotDisturb".to_string(),
            Self::Offline => "Offline".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum Colors {
    #[serde(rename = "Black")]
    Black,
    #[serde(rename = "White")]
    White,
    #[serde(rename = "Purple")]
    Purple,
}
impl ToString for Colors {
    fn to_string(&self) -> String {
        match self {
            Self::Black => "Black".to_string(),
            Self::White => "White".to_string(),
            Self::Purple => "Purple".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum UsersPrivacyLevel {
    #[serde(rename = "Default")]
    Default,
}
impl ToString for UsersPrivacyLevel {
    fn to_string(&self) -> String {
        match self {
            Self::Default => "Default".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum UsersRole {
    #[serde(rename = "Administrator")]
    Administrator,
    #[serde(rename = "Default")]
    Default,
}
impl ToString for UsersRole {
    fn to_string(&self) -> String {
        match self {
            Self::Administrator => "Administrator".to_string(),
            Self::Default => "Default".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ServerRole {
    #[serde(rename = "Administrator")]
    Administrator,
    #[serde(rename = "Default")]
    Default,
}
impl ToString for ServerRole {
    fn to_string(&self) -> String {
        match self {
            Self::Administrator => "Administrator".to_string(),
            Self::Default => "Default".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum MessageType {
    #[serde(rename = "Text")]
    Text,
    #[serde(rename = "Picture")]
    Picture,
    #[serde(rename = "Video")]
    Video,
    #[serde(rename = "Gif")]
    Gif,
    #[serde(rename = "Deleted")]
    Deleted,
}
impl ToString for MessageType {
    fn to_string(&self) -> String {
        match self {
            Self::Text => "Text".to_string(),
            Self::Picture => "Picture".to_string(),
            Self::Video => "Video".to_string(),
            Self::Gif => "Gif".to_string(),
            Self::Deleted => "Deleted".to_string(),
        }
    }
}
